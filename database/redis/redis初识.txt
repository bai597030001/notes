www.runoob.com/redis

https://blog.csdn.net/liqingtx/article/details/60330555
		
Redis 简介

	Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

	Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的
	日志型、Key-Value数据库，并提供多种语言的API。 
	它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 
	列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。
	
Redis 安装与启动
	
	win下
	
	linux下
		
		./redis-server ../redis.conf
		
		redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。
		
		启动 Redis		->		$ redis-server
		
		查看 redis 是否启动		->		$ redis-cli
		
		Redis 配置
			
			Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。
			你可以通过 CONFIG 命令查看或设置配置项。
			
				>	CONFIG GET CONFIG_SETTING_NAME
				>	CONFIG GET loglevel
				>	CONFIG GET *
				
				> 	CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE
				> 	CONFIG SET loglevel "notice"

				
在远程服务上执行命令				
				
	$redis-cli -h 127.0.0.1 -p 6379 -a "mypass"			
	
	
Redis 数据类型


	redis是一种高级的key:value存储系统，其中value支持五种数据类型：
	
		String（字符串）
		
		Hash（哈希）
		
		List（列表）
		
		Set（集合）
		
		zset(sorted set：有序集合)
	
	而关于key，有几个点要提醒大家：
	
		1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；
		2.key也不要太短，太短的话，key的可读性会降低；
		3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。
	
	
	https://blog.csdn.net/liqingtx/article/details/60330555
	
	
redis常用命令
	
	#查看所有key
	
		keys *  或  keys "*"

	#查看匹配前缀的keys

		keys "miao*"
		
	#清空redis
	
		flushdb

	#随机取出一个key

		randomkey
		
	#查看key的类型

		type key
		
	#查看数据库中key的数量

		dbsize
		
	#查看服务器信息

		info
		
	#查看redis正在做什么
		
		monitor   #注意，有高手的文章说这个会急剧降低redis性能，只能在测试环境使用。

	#查看日志
		slowlog get
		slowlog get 10	
		
	设置key的值,若存在则覆盖	
		
		set key value
		
	若存在则不操作
	
		setnx key value
		
	设置这些key的值，若存在则覆盖
	
		MSET key1 value1 key2 value2 ... keyN valueN
		
	同mset，但如果其中一个key已经存在了，则都不设置。这些操作都是原子的
	
		MSETNX key1 value1 key2 value2 ... keyN valueN
		
	重命名	
		rename key
		
	向key的字符串追加拼接
	
		append key value
		
	获取key对应的值 
		
		get key
		MGET key1 key2 ... keyN
		
	查看是否存在该元素
	
		EXISTS key
		
	获取该元素的值，并给该元素设置新值（通常和incr搭配使用，比如一个mycount一直incr，
	然后达到某些情况需要清零，清零之前需要知道mycount的值）
	
		GETSET key value
		
	删除元素
		del key
		
	重命名
		RENAME oldkey newkey
		
	incr key:原子的+1；
	
	DECR key：原子的-1；
	
	DECRBY key integer：原子的-integer；
	
	INCRBY key integer：原子的+integer
	
	redis可以定时存储，即设置几秒后删除该变量
		
		EXPIRE key seconds ：设置该元素多少秒后失效
		
		PEXPIRE key milliseconds ：设置该元素多少毫秒后失效
		
		ttl key : Time To Live，查看还可以存活多久，-2表示key不存在；-1表示定时任务消失，永久存储。
		
		SETEX key seconds value：等价于先设置变量再设置超时，即在缓存中使用：存储的同时设置超时时间，这个操作是原子的
		
		persist key:取消过期时间
		
		expireat key 时间戳：unix时间戳，1970.1.1之后，这个绝对时间，将在这个时间删除key。
							expireat pages:about 1356933600：在2012年12月31日上午12点删除掉关键字
		
		SETEX KEY_NAME TIMEOUT VALUE：设置key的值为value，并在timeout秒后失效，key将被删除
	
	
list : 存储有序队列

	rpush keyList value	:向keyList添加元素,向后加,r表示右边

	lpush keyList value :向keyList左边添加元素，LPUSH puts the new value at the start of the list.

	lrange keyList beginIndex endIndex :获取keyList的元素，用两端的索引取出子集，endIndex=-1则表示全部取出
	
	llen keyList :获取keyList的长度大小

	lpop keyList:取出并移除keyList第一个元素，左边的元素

	rpop keyList:取出并移除keyList最后一个元素，右边的元素

	LINDEX key index:获取该索引下的元素。

	lrem key count value:删除count个value。（count为正数,从头开始，删除count个value元素；
						count为负，则从尾部向头删除|count|个value元素；count为0，则所有的元素为value的都删除）

	LSET key index value:设置索引为index下的元素为value.超出索引范围报错。

	LTRIM key start end:清空索引在start 和end之外的元素，索引从0开始，两端保留，两端之外的清空。

	RPOPLPUSH srckey dstkey:源队列srckey，目标队列dstkey，将srckey的最后一个移除，并放到dstkey的第一个。
	
set : 无序且唯一集合
	
	和java中list与set的区别一样。这里的set无序且值唯一。
	
	sadd key value : 向set添加元素
	
	srem key value ：从set中移除元素
	
	smembers key : 取出所有set元素
	
	SISMEMBER key value: 查看value是否存在set中
	
	SUNION key1 key2 ... keyN:将所有key合并后取出来，相同的值只取一次
	
	scard key : 获取set中元素的个数
	
	SRANDMEMBER key: Return a random element from a Set, without removing the element.随机取出一个
	
	SDIFF key1 key2 ... keyN：获取第一set中不存在后面几个set里的元素。
	
	SDIFFSTORE dstkey key1 key2 ... keyN：和sdiff相同，获取key1中不存在其他key里的元素，但要存储到dstkey中。
	
	SINTER key1 key2 ... keyN:取出这些set的交集
	
	SINTERSTORE dstkey key1 key2 ... keyN：取出这些key的交集并存储到dstkey
	
	SMOVE srckey dstkey member：将元素member从srckey中转移到dstkey中，这个操作是原子的。
	
	
sorted set : 有序集合	

	和set一样，唯一。但z多了个score用来排序。所以命令又像list一样
	
	ZADD key score member：向有序set中添加元素member，其中score为分数，默认升序；

	ZRANGE key start end [WITHSCORES]:获取按score从低到高索引范围内的元素，索引可以是负数，
									-1表示最后一个，-2表示倒数第二个，即从后往前。withscores可选，表示获取包括分数。

	ZREVRANGE key start end [WITHSCORES]：同上，但score从高到低排序。

	ZCOUNT key min max：获取score在min和max范围内的元素的个数

	ZCARD key:获取集合中元素的个数。

	ZINCRBY key increment member:根据元素，score原子增加increment.

	ZREMRANGEBYSCORE key min max:清空集合内的score位于min和max之间的元素。

	ZRANK key member:获取元素的索引（照score从低到高排列）。

	ZREM key member:移除集合中的该元素

	ZSCORE key member:获取该元素的score

	
Hashes : 对象存储

	可以存储对象，比如人，编号，姓名，年龄等
	
	HSET key field value:key是对象名，field是属性，value是值；
	
	HMSET key field value [field value ...]:同时设置多个属性
	
	HGET key field：获取该对象的该属性
	
	HMGET key field value [field value ...]：获取多个属性值
	
	HGETALL key:获取对象的所有信息
	
	HKEYS key：获取对象的所有属性
	
	HVALS key：获取对象的所有属性值
	
	HDEL key field：删除对象的该属性
	
	HEXISTS key field:查看对象是否存在该属性
	
	HINCRBY key field value:原子自增操作，只能是integer的属性值可以使用；
	
	HLEN key: Return the number of entries (fields) contained in the hash stored at key.获取属性的个数。
	
Redis HyperLogLog : 
	
	http://www.runoob.com/redis/redis-hyperloglog.html
	
Redis 发布订阅 : 
	
	http://www.runoob.com/redis/redis-pub-sub.html
	
		publish		subscribe	......
		
Redis 事务:

	Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：
		
		批量操作在发送 EXEC 命令前被放入队列缓存。 

		收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。

		在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。
		
		
	一个事务从开始到执行会经历以下三个阶段： 
		
		开始事务。

		命令入队。

		执行事务。
	
	以下是一个事务的例子，先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令： 
		
		redis 127.0.0.1:6379> MULTI
		OK

		redis 127.0.0.1:6379> SET book-name "Mastering C++ in 21 days"
		QUEUED

		redis 127.0.0.1:6379> GET book-name
		QUEUED

		redis 127.0.0.1:6379> SADD tag "C++" "Programming" "Mastering Series"
		QUEUED

		redis 127.0.0.1:6379> SMEMBERS tag
		QUEUED

		redis 127.0.0.1:6379> EXEC
		1) OK
		2) "Mastering C++ in 21 days"
		3) (integer) 3
		4) 1) "Mastering Series"
		   2) "C++"
		   3) "Programming"
			
	单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

	事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，
	也不会造成后续的指令不做。	

	Redis 事务命令
		
		DISCARD 	取消事务，放弃执行事务块内的所有命令
		
		EXEC 		执行所有事务块内的命令
		
		MULTI 		标记一个事务块的开始
		
		UNWATCH 	取消 WATCH 命令对所有 key 的监视
		
		WATCH key [key ...] 	监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
	
	
Redis 连接	
	
	以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行： 
	
	redis 127.0.0.1:6379> AUTH "password"
	OK
	redis 127.0.0.1:6379> PING
	PONG
	
	Redis 连接命令
	
		ECHO message 	打印字符串
		
		QUIT 			关闭当前连接
		
		SELECT index 	切换到指定的数据库
		
		
Redis 服务器

	Redis 服务器命令主要是用于管理 redis 服务。
	
	redis 127.0.0.1:6379> INFO

	1
	BGREWRITEAOF 
	异步执行一个 AOF（AppendOnly File） 文件重写操作
	2
	BGSAVE 
	在后台异步保存当前数据库的数据到磁盘
	3
	CLIENT KILL [ip:port] [ID client-id] 
	关闭客户端连接
	4
	CLIENT LIST 
	获取连接到服务器的客户端连接列表
	5
	CLIENT GETNAME 
	获取连接的名称
	6
	CLIENT PAUSE timeout 
	在指定时间内终止运行来自客户端的命令
	7
	CLIENT SETNAME connection-name 
	设置当前连接的名称
	8
	CLUSTER SLOTS 
	获取集群节点的映射数组
	9
	COMMAND 
	获取 Redis 命令详情数组
	10
	COMMAND COUNT 
	获取 Redis 命令总数
	11
	COMMAND GETKEYS 
	获取给定命令的所有键
	12
	TIME 
	返回当前服务器时间
	13
	COMMAND INFO command-name [command-name ...] 
	获取指定 Redis 命令描述的数组
	14
	CONFIG GET parameter 
	获取指定配置参数的值
	15
	CONFIG REWRITE 
	对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写
	16
	CONFIG SET parameter value 
	修改 redis 配置参数，无需重启
	17
	CONFIG RESETSTAT 
	重置 INFO 命令中的某些统计数据
	18
	DBSIZE 
	返回当前数据库的 key 的数量
	19
	DEBUG OBJECT key 
	获取 key 的调试信息
	20
	DEBUG SEGFAULT 
	让 Redis 服务崩溃
	21
	FLUSHALL 
	删除所有数据库的所有key
	22
	FLUSHDB 
	删除当前数据库的所有key
	23
	INFO [section] 
	获取 Redis 服务器的各种信息和统计数值
	24
	LASTSAVE 
	返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示
	25
	MONITOR 
	实时打印出 Redis 服务器接收到的命令，调试用
	26
	ROLE 
	返回主从实例所属的角色
	27
	SAVE 
	同步保存数据到硬盘
	28
	SHUTDOWN [NOSAVE] [SAVE] 
	异步保存数据到硬盘，并关闭服务器
	29
	SLAVEOF host port 
	将当前服务器转变为指定服务器的从属服务器(slave server)
	30
	SLOWLOG subcommand [argument] 
	管理 redis 的慢日志
	31
	SYNC 
	用于复制功能(replication)的内部命令
	
redis持久化 C 两种方式

	RDB（Redis DataBase）和AOF（Append Only File）
	
		RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；
		
		AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，
		在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
		
		其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，
		则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。
		
		如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，
		redis将变成一个纯内存数据库，就像memcache一样。
		
		
		redis持久化 C RDB
		
			RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。
			
			redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，
			才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，
			因为快照文件总是完整可用的。
			
			对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，
			这样就确保了redis极高的性能。
			
			如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
			虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，
			那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，
			仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。
			
		redis持久化 C AOF
		
			AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。
			
			通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。
			
			默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），
			因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。
			
			如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，
			redis提供了redis-check-aof工具，可以用来进行日志修复。
			
			
			AOF重写
				
		
		如何选择RDB和AOF
			
			官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。