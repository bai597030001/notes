一、类模板
类的成员变量、成员函数(返回、参数、函数体)、成员类型、基类，这些带有类型特性的成分统统可以被参数化，这样的类就被称为类模板。
1.类模板的定义
1)语法形式
template<typename 类型形参1,
    typename 类型形参2, ...>
class 类模板名 [继承表] { ... };
例如：
template<typename A, typename b,
    typename _C, typename X>
class MyClass : public X {
public:
    b foo (_C c) { ... }
    typedef A* pointer;
private:
    A m_a;
};
2)类型参数
在类模板的内部，类型参数可以象其它任何具体类型一样，用于成员变量、成员函数、成员类型(内部类型)，甚至基类的声明。
2.类模板的使用
1)实例化语法
类   模    板<类型实参1, 类型实参2, ...>
|<-模板->|
|<-----------------类----------------->|
                               |
                              v
        创建对象、声明指针或者引用、
                   实例化其它模板
2)两步实例化
             编译时            运行时
类模板--实例化-->类--实例化-->对象
              编译器            处理器
类模板本身并不代表一个确定的类型，既不能用于定义对象，也不能用于声明指针或引用。只有通过模板实参将其实例化为具体类以后，才具备类型语义。
3)调用谁实例化谁
类模板中，只有那些被调用的成员函数才会被实例化，即产生实例化代码。某些类型虽然并没有提供类模板所需要的全部功能，但照样可以实例化该类模板，只要不直接或间接调用那些依赖于未提供功能的成员函数即可。
4)类模板参数不支持隐式推断，必须显式实例化。
Comparator ci (123, 456); // ERROR
Comparator<int> ci (123, 456); // OK
3.类模板的静态成员
类模板的静态成员变量，既不是一个对象一份，也不是一个模板一份，而是在该类模板的每个实例化类中，各有一份独立的拷贝，且为该类的所有实例化对象所共享。
4.类模板的递归实例化
1)类模板的类型实参可以是任何类型，只要该类型能够提供模板所需要的功能。
2)模板自身的实例化类亦可实例化其自身，谓之递归实例化。通过这种方法可以很容易地构建那些在空间上具有递归特性的数据结构，比如数组、二叉树、广义表，等等。
template<typename T> List { ... };
List<List<int> > ll;
Array<List<int> > al; // 散列表
5.类模板的完全特化
1)全类特化
特化一个类模板可以特化该类模板的所有成员函数，相当于重新写了一个针对某种特定类型的具体类。
template<>
class 类模板名<所针对的具体类型> { ... };
2)成员特化
类模板除了一个整体特化以外，也可以只针对部分与特定类型相关的成员函数进行特化。注意，成员函数的特化版本和通用版本除了一个针对具体类型，一个针对类型参数之外，其接口规格必须完全一致。
6.类模板的局部(偏)特化
1)类模板可以被局部特化，即一方面为类模板指定特定的实现，另一方面又允许用户对部分模板参数自行指定。
如果多个局部特化同等程度地匹配某个声明，那么该声明将因二义性而导致歧义错误，除非存在更好的匹配。
2)局部特化必须针对整个类模板进行，不能针对具体函数(成员函数或全局函数)进行。
二、模板的缺省参数
1.类模板的模板参数可以带有缺省值，即缺省模板实参。实例化类模板时，如果提供了模板实参则用所提供的模板实参实例化相应的模板形参，如果没有提供模板实参则相应的模板形参缺省值。
2.如果类模板的某个模板参数带有缺省值，那么它后面的所有模板参数必须都带有缺省值。
template<typename A, typename B = int,
    typename C = double> ... // OK
template<typename A = int, typename B,
    typename C = double> ... // ERROR
3.函数模板在C++98中不允许带有缺省的模板参数，但是在C++11中可以带。函数模板的调用参数无论在C++98还是C++11中都可以带有参数。
4.当函数模板的模板参数隐式推断的类型和缺省参数的类型不一致时，以隐式推断为准。
5.在模板中，可以用前面模板参数的值作为后面模板参数的缺省值。
三、模板的非类型参数
1.模板的参数并不局限于类型参数，普通的数值也可以作为模板的参数，前面不要写typename，而要写具体类型。
2.模板的非类型参数只能是常量、常量表达式、以及带有常属性的变量，但是不能同时具有挥发性(volatile)。
四、typename关键字
1.声明模板参数：template<typename T> ...，只有在这种语境下，typename关键字才可以和class关键字互换。
2.解决嵌套依赖：当编译器第一次编译模板代码时，模板参数的具体类型尚不明确，编译器会把依赖于模板参数的嵌套类型理解为某个类的静态成员变量。因此当它看到代码中使用这样的标识符声明其它变量时，会报告错误，这就叫做嵌套依赖异常。typename关键字旨在告诉编译器，所引用的标识符是个类型名，可以声明变量，具体类型等到实例化时再定。
         class -  声明类
                   \ 声明模板的
                   / 类型参数
typename -  解决嵌套依赖
无论是声明模板的类型参数还是解决嵌套依赖struct关键字都不能使用。
五、template关键字
1.声明模板：template<...> 函数或者类
2.解决依赖模板参数的模板成员访问问题：在模板代码中，通过依赖于模板参数的对象、引用或指针，访问其带有模板特性的成员，编译器常常因为无法正确理解模板参数列表的左右尖括号，而报告错误。这时候，在模板名前面加上template关键字，意在告诉编译器其后的名称是一个模板，编译器就可以正确理解“<>”了。