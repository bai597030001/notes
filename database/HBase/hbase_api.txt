hbase操作api可见官网

1. Apache HBase APIs 是 hbase 官方提供的操作 api

2. Using Java Data Objects (JDO) 是官方提供的 java 操作 api, 需要几个以来条件方可使用。

	HBase 0.90.x or newer

	commons-beanutils.jar (https://commons.apache.org/)

	commons-pool-1.5.5.jar (https://commons.apache.org/)

	transactional-tableindexed for HBase 0.90 (https://github.com/hbase-trx/hbase-transactional-tableindexed)


3. Apache HBase APIs 使用总结

	https://blog.csdn.net/wulantian/article/details/41011297
	
		对于数据操作，HBase支持四类主要的数据操作，分别是：
	
			Put ：增加一行，修改一行；
			
			Delete ：删除一行，删除指定列族，删除指定column的多个版本，删除指定column的制定版本等；

			Get ：获取指定行的所有信息，获取指定行和指定列族的所有colunm，获取指定column，获取指定column的几个版本， 获取指定column的指定版本等； 

			Scan ：获取所有行，获取指定行键范围的行，获取从某行开始的几行，获取满足过滤条件的行等。
		
		这四个类都是 org.apache.hadoop.hbase.client的子类，可以到官网API去查看详细信息
	
	3.1 命名空间Namespace
	
		3.1.1
			create_namespace 'my_ns'		create 'my_ns:my_table', 'fam'
			
			drop_namespace 'my_ns'
			
			alter_namespace 'my_ns', {METHOD => 'set', 'PROPERTY_NAME' => 'PROPERTY_VALUE'}
			
		3.1.2 预定义的命名空间
		
			hbase ：系统命名空间，用于包含hbase的内部表 

			default ： 所有未指定命名空间的表都自动进入该命名空间
			
	3.2 创建表
	
		Configuration conf = HBaseConfiguration.create ();
        HBaseAdmin admin =  new  HBaseAdmin(conf);
         //create  namespace  named "my_ns"
        admin.createNamespace(NamespaceDescriptor. create ( "my_ns" ).build());
        
         //create tableDesc, with  namespace  name "my_ns" and table name "mytable "
        HTableDescriptor tableDesc =  new  HTableDescriptor(TableName. valueOf ("my_ns:mytable" ));
         tableDesc.setDurability(Durability.SYNC_WAL );
         //add a column family " mycf "
        HColumnDescriptor hcd =  new  HColumnDescriptor( "mycf" );
        tableDesc.addFamily(hcd);
        admin.createTable(tableDesc);

        admin.close();
		
		关键知识点：
			
			1. 必须将HBase集群的 hbase-site.xml 文件添加进工程的 classpath 中，
			
				否则Configuration conf = HBaseConfiguration. create () 
				
				代码获取不到需要的集群相关信息，也就无法找到集群，运行程序时会报错； 

			2. HTableDescriptor tableDesc =  new  HTableDescriptor(TableName. valueOf ("my_ns:mytable" )) 
			
				代码是描述表 mytable ，并将 mytable 放到了 my_ns 命名空间中，前提是该命名空间已存在，
				
				如果指定的是不存在命名空间，则会报 错 org.apache.hadoop.hbase.NamespaceNotFoundException；
				

			3. 命名空间一般在建模阶段通过命令行创建，在java代码中通过
			
				admin.createNamespace(NamespaceDescriptor. create ( "my_ns" ).build()) 创建的机会不多；

			4. 创建 HBaseAdmin 对象时就已经建立了客户端程序与 HBase 集群的 connection ，
				
				所以在程序执行完成后，务必通过 admin.close() 关闭 connection；

			5. 可以通过 HTableDescriptor 对象设置 表的特性 ，比如： 通过 tableDesc.setMaxFileSize(512) 
			
				设置一个 region 中的 store 文件的最大 size ，当一个 region 中的最大 store 文件达到这个 size 时，
				
				region 就开始分裂； 通过 tableDesc.setMemStoreFlushSize(512) 设置 region 内存中的 memstore 的最大值，
				
				当 memstore 达到这个值时，开始往磁盘中刷数据。 更多特性请自行查阅官网API；

			6. 可以通过 HColumnDescriptor 对象设置 列族的特性 ，比如：通过 hcd.setTimeToLive(5184000) 设置数据保存的最长时间；
			
				通过 hcd.setInMemory(true ) 设置数据保存在内存中以提高响应速度；
				
				通过 hcd.setMaxVersions(10) 设置数据保存的最大版本数；
				
				通过 hcd.setMinVersions(5) 设置数据保存的最小版本数（配合 TimeToLive 使用）。更多特性请自行查阅官网API； 

			7. 数据的版本数只能通过 HColumnDescriptor 对象设置，不能通过 HTableDescriptor 对象设置；

			8. 由于 HBase 的数据是先写入内存，数据累计达到内存阀值时才往磁盘中flush数据，所以，
			
				如果在数据还没有 flush 进硬盘时， regionserver down 掉了，内存中的数据将丢失。
				
				要想解决这个场景的问题就需要用到 WAL （Write-Ahead-Log）， 
				
				tableDesc.setDurability(Durability. SYNC_WAL ) 就是设置写 WAL 日志的级别，
				
				示例中设置的是同步写 WAL，该方式安全性较高，但无疑会一定程度影响性能，请根据具体场景选择使用；

			9. setDurability (Durability d)方法可以在相关的三个对象中使用，
				
				分别是： HTableDescriptor ， Delete ， Put （其中Delete和Put的该方法都是继承自父类
				
				org.apache.hadoop.hbase.client.Mutation ） 。分别针对表、插入操作、删除操作设定 WAL 日志写入级别。
				
				需要注意的是， Delete 和 Put 并不会继承 Table 的 Durability 级别（已实测验证） 。
				
				Durability是一个枚举变量，可选值参见4.2节。如果不通过该方法指定WAL日志级别，则为 默认 USE_DEFAULT 级别。

	3.3 删除表
	
		删除表没创建表那么多学问，直接上代码：
		
        Configuration conf = HBaseConfiguration. create ();
        HBaseAdmin admin =  new  HBaseAdmin(conf);
        String tablename =  "my_ns:mytable" ;
         if (admin.tableExists(tablename)) {
             try  {
                admin.disableTable(tablename);
                admin.deleteTable(tablename);
            }  catch  (Exception e) {
                 //  TODO : handle exception
                e.printStackTrace();
            }
        }

        admin.close();
   

		说明 ：删除表前必须先disable表。
		
	3.4. 修改表
	
		1）删除列族、新增列族
		
			修改表，删除三个列族，新增一个列族，代码如下：
			
			Configuration conf = HBaseConfiguration. create ();
			HBaseAdmin admin =  new  HBaseAdmin(conf);
			String tablename =  "rd_ns:itable" ;
			 if (admin.tableExists(tablename)) {
				 try  {
					admin.disableTable(tablename);
					 //get the TableDescriptor of target table
					HTableDescriptor newtd =  admin.getTableDescriptor (Bytes. toBytes ("rd_ns:itable" ));
					
					 //remove 3 useless column families
					newtd.removeFamily(Bytes. toBytes ( "note" ));
					newtd.removeFamily(Bytes. toBytes ( "newcf" ));
					newtd.removeFamily(Bytes. toBytes ( "sysinfo" ));
					
					 //create HColumnDescriptor for new column family
					HColumnDescriptor newhcd =  new  HColumnDescriptor( "action_log" );
					newhcd.setMaxVersions(10);
					newhcd.setKeepDeletedCells( true );
					
					 //add the new column family(HColumnDescriptor) to HTableDescriptor
					newtd.addFamily(newhcd);
					
					 //modify target table  struture
					admin. modifyTable (Bytes. toBytes ( "rd_ns:itable" ),newtd);
					
					admin.enableTable(tablename);
				}  catch  (Exception e) {
					 //  TODO : handle exception
					e.printStackTrace();
				}
			}
			admin.close();
			
			逻辑很简单：
			
				通过 admin.getTableDescriptor (Bytes. toBytes ( "rd_ns:itable" )) 取得目标表的描述对象，应该就是取得指向该对象的指针了； 
				
				修改目标表描述对象； 
				
				通过 admin. modifyTable (Bytes. toBytes ( "rd_ns:itable" ),newtd) 将修改后的描述对象应用到目标表。 
				
				
		2）修改现有列族的属性（setMaxVersions）
		
			Configuration conf = HBaseConfiguration. create ();
			HBaseAdmin admin =  new  HBaseAdmin(conf);
			String tablename =  "rd_ns:itable" ;
			 if (admin.tableExists(tablename)) {
				 try  {
					admin.disableTable(tablename);
					 //get the TableDescriptor of target table
					HTableDescriptor htd = admin.getTableDescriptor(Bytes. toBytes ("rd_ns:itable" ));
					HColumnDescriptor infocf = htd.getFamily(Bytes. toBytes ( "info" ));
					infocf.setMaxVersions(100);
					 //modify target table  struture
					admin.modifyTable(Bytes. toBytes ( "rd_ns:itable" ),htd);
					admin.enableTable(tablename);
				}  catch  (Exception e) {
					 //  TODO : handle exception
					e.printStackTrace();
				}
			}

			admin.close();
				
				
	3.5. 新增、更新数据 Put
	
		5.1.常用构造函数：
		
			（1）指定行键
				
				public Put(byte[] row)
			
				参数： row 行键
			
			（2）指定行键和时间戳
				
				public Put(byte[] row, long ts)
				
				参数： row 行键， ts 时间戳
			
			（3）从目标字符串中提取子串，作为行键
				
				Put(byte[] rowArray, int rowOffset, int rowLength)
			
			（4）从目标字符串中提取子串，作为行键，并加上时间戳
				
				Put(byte[] rowArray, int rowOffset, int rowLength, long ts)
				
		5.2.常用方法：
		
			（1）指定 列族、限定符 ，添加值
			
				add(byte[] family, byte[] qualifier, byte[] value)
			
			（2）指定 列族、限定符、时间戳 ，添加值
			
				add(byte[] family, byte[] qualifier, long ts, byte[] value)
			
			（3） 设置写WAL （Write-Ahead-Log）的级别
			
				public void setDurability(Durability d)
			
			参数是一个枚举值，可以有以下几种选择：
			
				ASYNC_WAL ： 当数据变动时，异步写WAL日志
				SYNC_WAL ： 当数据变动时，同步写WAL日志
				FSYNC_WAL ： 当数据变动时，同步写WAL日志，并且，强制将数据写入磁盘
				SKIP_WAL ： 不写WAL日志
				USE_DEFAULT ： 使用HBase全局默认的WAL写入级别，即 SYNC_WAL 
				
		5.3 实例代码
		
			1）插入行
			
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:leetable" );
				
				Put put =  new  Put(Bytes. toBytes ( "100001" ));
				put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "name" ), Bytes. toBytes ("lion" ));
				put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "address" ), Bytes. toBytes ("shangdi" ));
				put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "age" ), Bytes. toBytes ("30" ));

				put.setDurability(Durability. SYNC_WAL );
		   
				table.put(put);

				table.close();
   

			2）更新行
			
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:leetable" );
				
				Put put =  new  Put(Bytes. toBytes ( "100001" ));
				put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "name" ), Bytes. toBytes ("lee" ));
				put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "address" ), Bytes. toBytes ("longze" ));
				put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "age" ), Bytes. toBytes ("31" ));

				put.setDurability(Durability. SYNC_WAL );

				table.put(put);         

				table.close();
				
			注意：
			
				Put 的构造函数都需要指定行键，如果是全新的行键，则新增一行；如果是已有的行键，则更新现有行。
				
				创建 Put 对象及 put.add 过程都是在构建一行的数据，创建 Put 对象时相当于创建了行对象，
					add 的过程就是往目标行里添加 cell ，直到 table.put 才将数据插入表格；
				
				以上代码创建 Put 对象用的是构造函数1，也可用构造函数2，第二个参数是时间戳； 
				
				Put还有别的构造函数，请查阅官网API。
				
			3） 从目标字符串中提取子串，作为行键，构建 Put
			
					Configuration conf = HBaseConfiguration. create ();
					HTable table =  new  HTable(conf,  "rd_ns:leetable" );
					
					Put put =  new  Put(Bytes. toBytes ( "100001_100002" ),7,6);
					put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "name" ), Bytes. toBytes ("show" ));
					put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "address" ), Bytes. toBytes ("caofang" ));
					put.add(Bytes. toBytes ( "info" ), Bytes. toBytes ( "age" ), Bytes. toBytes ("30" ));
					
					table.put(put);

					table.close();
					
				注意，关于： Put put =  new  Put(Bytes. toBytes ( "100001_100002" ),7,6)
				
					第二个参数是偏移量，也就是行键从第一个参数的第几个字符开始截取；
					
					第三个参数是截取长度；
					
					这个代码实际是从 100001_100002 中截取了100002子串作为目标行的行键。
					
					
	3.6 删除数据 Delete
	
		Delete 类用于删除表中的一行数据，通过 HTable.delete 来执行该动作。

		在执行 Delete 操作时，HBase并不会立即删除数据，而是对需要删除的数据打上一个“墓碑”标记，
			直到当 Storefile 合并时，再清除这些被标记上“墓碑”的数据。

		如果希望删除整行，用行键来初始化一个 Delete 对象即可。
		
		如果希望进一步定义删除的具体内容，可以使用以下这些 Delete 对象的方法：
		
			为了删除指定的列族，可以使用 deleteFamily
			
			为了删除指定列的多个版本，可以使用 deleteColumns
			
			为了删除指定列的 指定版本 ，可以使用 deleteColumn ，这样的话就只会删除版本号 （时间戳） 与指定版本相同的列。
			如果不指定时间戳，默认只删除最新的版本
			
		下面详细说明构造函数和常用方法：
		
			6.1.构造函数
			
				（1）指定要删除的行键
				
					Delete(byte[] row)
					
					删除行键指定行的数据。
					
					如果没有进一步的操作，使用该构造函数将删除行键指定的行中 所有列族中所有列的所有版本 ！
				
				（2）指定要删除的行键和时间戳
				
				Delete(byte[] row, long timestamp)
				
					删除行键和时间戳共同确定行的数据。
					
					如果没有进一步的操作，使用该构造函数将删除行键指定的行中，所有列族中所有列的 时间戳 小于等于 指定时间戳的数据版本 。
					
					注意 ：该时间戳仅仅和删除行有关，如果需要进一步指定列族或者列，你必须分别为它们指定时间戳。
				
				（3）给定一个字符串，目标行键的偏移，截取的长度
				
					Delete(byte[] rowArray, int rowOffset, int rowLength)
				
				（4）给定一个字符串，目标行键的偏移，截取的长度，时间戳
				
					Delete(byte[] rowArray, int rowOffset, int rowLength, long ts)
					
			6.2.常用方法
			
				Delete   deleteColumn (byte[] family, byte[] qualifier)     
				删除指定列的 最新版本 的数据。
				
				Delete   deleteColumns (byte[] family, byte[] qualifier)     
				删除指定列的 所有版本的数据。
				
				Delete   deleteColumn (byte[] family, byte[] qualifier, long  timestamp )     
				删除指定列的 指定版本 的数据。
				
				Delete   deleteColumns (byte[] family, byte[] qualifier, long  timestamp )     
				删除指定列的，时间戳 小于等于给定时间戳 的 所有 版本的数据。
				
				Delete   deleteFamily (byte[] family)     
				删除指定列族的所有列的 所有 版本数据。
				
				Delete   deleteFamily (byte[] family, long timestamp)     
				删除指定列族的所有列中时间戳 小于等于 指定时间戳 的所有数据。
				
				Delete   deleteFamilyVersion (byte[] family, long timestamp)     
				删除指定列族中所有 列的时间戳 等于 指定时间戳 的版本数据。
				
				void setTimestamp (long timestamp)     
				为Delete对象设置时间戳。
				
			6.3.实例代码
			
				1）删除整行的所有列族、所有行、所有版本
				
					Configuration conf = HBaseConfiguration. create ();
					HTable table =  new  HTable(conf,  "rd_ns:leetable" );
					
					Delete delete =  new  Delete(Bytes. toBytes ( "000" ));
					table.delete(delete);

					table.close();
					
				2）删除 指定列的最新版本
				
					Configuration conf = HBaseConfiguration. create ();
					HTable table =  new  HTable(conf,  "rd_ns:leetable" );
					Delete delete =  new  Delete(Bytes. toBytes ( "100003" ));
					delete.deleteColumn(Bytes. toBytes ( "info" ), Bytes. toBytes ( "address" ));
					
					table.delete(delete);

					table.close();
					
				3）删除 指定列的所有版本
					Configuration conf = HBaseConfiguration. create ();
					HTable table =  new  HTable(conf,  "rd_ns:leetable" );
					Delete delete =  new  Delete(Bytes. toBytes ( "100003" ));
					delete. deleteColumns (Bytes. toBytes ( "info" ), Bytes. toBytes ( "address"));
					
					table.delete(delete);

					table.close();
					
				4） 删除指定列族中所有 列的时间戳 等于 指定时间戳 的版本数据
				
					Configuration conf = HBaseConfiguration. create ();
					HTable table =  new  HTable(conf,  "rd_ns:leetable" );
					
					Delete delete =  new  Delete(Bytes. toBytes ( "100003" ));
					delete. deleteFamilyVersion (Bytes. toBytes ( "info" ), 1405390959464L);
					
					table.delete(delete);

					table.close();
					
	3.7 获取单行 Get
	
		如果希望获取整行数据，用行键初始化一个Get对象就可以;
		
		如果希望进一步缩小获取的数据范围，可以使用Get对象的以下方法：
		
			如果希望取得指定列族的所有列数据，使用 addFamily 添加所有的目标列族即可； 
			
			如果希望取得指定列的数据，使用 addColumn 添加所有的目标列即可； 
			
			如果希望取得目标列的指定时间戳范围的数据版本，使用 setTimeRange ； 
			
			如果仅希望获取目标列的指定时间戳版本，则使用 setTimestamp ； 
			
			如果希望限制每个列返回的版本数，使用 setMaxVersions ； 
			
			如果希望添加过滤器，使用 setFilter 
			
			
		下面详细描述构造函数及常用方法：
		
		7.1.构造函数

			Get的构造函数很简单，只有一个构造函数： Get(byte[] row) 参数是行键。
			
		7.2.常用方法
		
			Get addFamily(byte[] family)  指定希望获取的列族 
			
			Get addColumn(byte[] family, byte[] qualifier)  指定希望获取的列 
			
			Get setTimeRange(long minStamp, long maxStamp)  设置获取数据的 时间戳范围
			
			Get setTimeStamp(long timestamp)  设置获取数据的时间戳 
			
			Get setMaxVersions(int maxVersions) 设定获取数据的版本数 
			
			Get setMaxVersions()  设定获取数据的 所有版本 
			
			Get setFilter(Filter filter)  为Get对象添加过滤器，
				过滤器详解请参见：http://blog.csdn.net/u010967382/article/details/37653177 
			
			void setCacheBlocks(boolean cacheBlocks)  设置该Get获取的数据是否缓存在内存中 
			
		7.3.实测代码
		
			1）获取行键指定行的 所有列族、所有列 的 最新版本 数据
        
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:leetable" );
				Get get =  new  Get(Bytes. toBytes ( "100003" ));
				Result r = table.get(get);
				 for  (Cell cell : r.rawCells()) {
					System. out .println(
							 "Rowkey : " +Bytes. toString (r.getRow())+
							 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier (cell))+
							 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))
							);
				}

				table.close();
				
			2）获取行键指定行中， 指定列 的最新版本数据
        
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:leetable" );
				Get get =  new  Get(Bytes. toBytes ( "100003" ));
				 get.addColumn(Bytes. toBytes ( "info" ), Bytes. toBytes ( "name" ));
				Result r = table.get(get);
				 for  (Cell cell : r.rawCells()) {
					System. out .println(
							 "Rowkey : " +Bytes. toString (r.getRow())+
							 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier (cell))+
							 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))
							);
				}

				table.close();
				
			3）获取行键指定的行中， 指定时间戳 的数据
        
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:leetable" );
				Get get =  new  Get(Bytes. toBytes ( "100003" ));
				 get.setTimeStamp(1405407854374L);
				Result r = table.get(get);
				 for  (Cell cell : r.rawCells()) {
					System. out .println(
							 "Rowkey : " +Bytes. toString (r.getRow())+
							 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier (cell))+
							 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))
							);
				}

				table.close(); 
				
	3.8 获取多行 Scan
	
		Scan 对象可以返回满足给定条件的多行数据。 如果希望获取所有的行，直接初始化一个Scan对象即可。 
		
		如果希望限制扫描的行范围，可以使用以下方法：
		
			如果希望获取指定列族的所有列，可使用 addFamily 方法来添加所有希望获取的列族 
			
			如果希望获取指定列，使用 addColumn 方法来添加所有列
			
			通过 setTimeRange 方法设定获取列的时间范围
			
			通过 setTimestamp 方法指定具体的时间戳，只返回该时间戳的数据
			
			通过 setMaxVersions 方法设定最大返回的版本数
			
			通过 setBatch 方法设定返回数据的最大行数
			
			通过 setFilter 方法为Scan对象添加过滤器，过滤器详解请参见：http://blog.csdn.net/u010967382/article/details/37653177
			
			Scan 的结果数据是可以缓存在内存中的，可以通过 getCaching ()方法来查看当前设定的缓存条数，
				
				也可以通过 setCaching (int caching)来设定缓存在内存中的行数，缓存得越多，以后查询结果越快，同时也消耗更多内存。
				
				此外， 通过 setCacheBlocks 方法设置是否缓存 Scan 的结果数据块，默认为 true
			
			我们可以通过 setMaxResultSize(long)方法来设定 Scan 返回的结果行数。
			
			
		下面是官网文档中的一个入门示例：假设表有几行键值为 "row1", "row2", "row3"，还有一些行有键值 
		
		"abc1", "abc2", 和 "abc3"，目标是返回"row"打头的行：
		
			
			HTable htable = ...      // instantiate HTable
			Scan scan = new Scan();
			scan.addColumn(Bytes.toBytes("cf"),Bytes.toBytes("attr"));
			scan.setStartRow( Bytes.toBytes("row"));                   // start key is inclusive
			scan.setStopRow( Bytes.toBytes("row" +  (char)0));  // stop key is exclusive
			ResultScanner rs = htable.getScanner(scan);
			try {
			for (Result r = rs.next(); r != null; r = rs.next()) {
			// process result...
			} finally {
			rs.close(); // always close the ResultScanner!
			}
			
			
		8.1.常用构造函数
			（1）创建扫描所有行的Scan
				
				Scan()
			
			（2）创建Scan，从指定行开始扫描 ，
				
				Scan(byte[] startRow)
				参数： startRow 行键
				注意 ：如果指定行不存在，从下一个最近的行开始
			
			（3）创建Scan，指定起止行
				
				Scan(byte[] startRow, byte[] stopRow)
				参数： startRow起始行， stopRow终止行
				注意 ： startRow <= 结果集 <  stopRow
			
			（4）创建Scan，指定起始行和过滤器
				
				Scan(byte[] startRow, Filter filter)
				参数： startRow 起始行， filter 过滤器
				注意：过滤器的功能和构造参见http://blog.csdn.net/u010967382/article/details/37653177
				
		8.2.常用方法
		
			Scan   setStartRow (byte[] startRow)   
				
				设置Scan的开始行， 默认 结果集 包含 该行。 如果希望结果集不包含该行，可以在行键末尾加上0。
			
			Scan   setStopRow (byte[] stopRow)    
			
				设置Scan的结束行， 默认 结果集 不包含该行。 如果希望结果集包含该行，可以在行键末尾加上0。
			
			Scan   setTimeRange (long minStamp, long maxStamp)    
			
				扫描指定 时间范围 的数据
			
			Scan   setTimeStamp (long timestamp)  
			
				扫描指定 时间 的数据
			
			Scan   addColumn (byte[] family, byte[] qualifier)   
			
				指定扫描的列
			
			Scan   addFamily (byte[] family) 
			
				指定扫描的列族
			
			Scan   setFilter (Filter filter)   
			
				为Scan设置过滤器
			
			Scan   setReversed (boolean reversed)  
			
				设置Scan的扫描顺序，默认是正向扫描（false），可以设置为逆向扫描（true）。注意：该方法0.98版本以后才可用！！
			
			Scan   setMaxVersions ()  
			
				获取所有版本的数据 
			
			Scan   setMaxVersions (int maxVersions)  
			
				设置获取的最大版本数
			
			void   setCaching (int caching)   
			
				设定缓存在内存中的行数，缓存得越多，以后查询结果越快，同时也消耗更多内存
			
			void setRaw (boolean raw)  
			
				激活或者禁用raw模式。如果raw模式被激活，Scan将返回 所有已经被打上删除标记但尚未被真正删除 的数据。
				
				该功能仅用于激活了KEEP_DELETED_ROWS的列族，即列族开启了 hcd.setKeepDeletedCells(true)。
				
				Scan激活raw模式后，就不能指定任意的列，否则会报错
				
				
		8.3.实测代码
		
			1）扫描表中的 所有行 的最新版本数据
			
				 Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:itable" );
				
				Scan s =  new  Scan();
				ResultScanner rs = table.getScanner(s);
				 for  (Result r : rs) {
					 for  (Cell cell : r.rawCells()) {
						System. out .println(
								 "Rowkey : " +Bytes. toString (r.getRow())+
								 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier(cell))+
								 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))+
								 "   Time : " +cell.getTimestamp()
								);
					}
				}

				table.close();
				
			2） 扫描指定行键范围，通过末尾加0，使得结果集包含StopRow
			
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:itable" );
				Scan s =  new  Scan();
				s. setStartRow (Bytes. toBytes ( "100001" ));
				s. setStopRow (Bytes. toBytes ( " 1000020 " ));
				
				ResultScanner rs = table.getScanner(s);
				 for  (Result r : rs) {
					 for  (Cell cell : r.rawCells()) {
						System. out .println(
								 "Rowkey : " +Bytes. toString (r.getRow())+
								 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier(cell))+
								 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))+
								 "   Time : " +cell.getTimestamp()
								);
					}
				}

				table.close();
				
			3） 返回 所有已经被打上删除标记但尚未被真正删除 的数据
			
				Configuration conf = HBaseConfiguration. create ();
				HTable table =  new  HTable(conf,  "rd_ns:itable" );
				Scan s =  new  Scan();
				s.setStartRow(Bytes. toBytes ( "100003" ));
				s.setRaw( true );
				s.setMaxVersions();
				
				ResultScanner rs = table.getScanner(s);
				 for  (Result r : rs) {
					 for  (Cell cell : r.rawCells()) {
						System. out .println(
								 "Rowkey : " +Bytes. toString (r.getRow())+
								 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier(cell))+
								 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))+
								 "   Time : " +cell.getTimestamp()
								);
					}
				}
				table.close();
				
			4） 结合过滤器，获取所有age在25到30之间的行
			
					Configuration conf = HBaseConfiguration. create ();
					HTable table =  new  HTable(conf,  "rd_ns:itable" );
					FilterList filterList =  new  FilterList(FilterList.Operator. MUST_PASS_ALL );  
					SingleColumnValueFilter filter1 =  new  SingleColumnValueFilter(
							Bytes. toBytes ( "info" ),
							Bytes. toBytes ( "age" ),
							CompareOp. GREATER_OR_EQUAL ,
							Bytes. toBytes ( "25" )
							);
					SingleColumnValueFilter filter2 =  new  SingleColumnValueFilter(
							Bytes. toBytes ( "info" ),
							Bytes. toBytes ( "age" ),
							CompareOp. LESS_OR_EQUAL ,
							Bytes. toBytes ( "30" )
							);
					filterList.addFilter(filter1);
					filterList.addFilter(filter2);
					
					Scan scan =  new  Scan();
					scan.setFilter(filterList);
					
					ResultScanner rs = table.getScanner(scan);
					 for  (Result r : rs) {
						 for  (Cell cell : r.rawCells()) {
							System. out .println(
									 "Rowkey : " +Bytes. toString (r.getRow())+
									 "   Familiy:Quilifier : " +Bytes. toString (CellUtil. cloneQualifier(cell))+
									 "   Value : " +Bytes. toString (CellUtil. cloneValue (cell))+
									 "   Time : " +cell.getTimestamp()
									);
						}
					}

					table.close();
					
			注意：
				HBase对列族、列名大小写敏感 
				
				关于过滤器请参见我的另外一篇博客：http://blog.csdn.net/u010967382/article/details/37653177
				
				
	3.9 Result 类
	
		当用户使用 get() 方法获取数据时， HBase 返回的结果包含所有匹配的单元格数据，
		
		这些数据将被封装在一个Result实例中返回给用户。用它提供的方法，可以从服务器端
		
		获取匹配指定行的特定返回值，这些值包括列族、列限定符和时间戳等。
		
		提供的方法如下:
		
		
			byte[] getValue(byte[] family,byte[] qualifier)
			
				getValue()方法允许用户取得一个HBase中存储的特定单元格的值。
				
				因为该方法不能指定时间戳，所以用户只能获取数据最新的版本。
			
			byte[] value()
			
				value()方法的使用更简单，它会返回第一个列对应的最新单元格的值。
				
				因为列在服务器端是按字典存储的，所以会返回名称（包括列族和列限定符）排在首位的那一列的值。 
				
			byte[] getRow()
			
				getRow()方法:它返回创建 Get 类当前实例使用的行键
			
			int size()
			
				size()方法返回服务器端返回值中键值对（KeyValue实例)的数目。
			
			boolean isEmpty()
			
			KeyValue[] raw()
			
				raw(）方法返回原始的底层 KeyValue 的数据结构
				
				具体来说，是基于当前的 Result 实例返回 KeyValue 实例的数组
				
				
				raw(）方法返回的数组已经按照字典序排列，排列时考虑了KeyValue实例的所有坐标。
				
				先按列族排序，列族内再按列限定符排序，此后再按时间戳排序，最后按类型排序 
			
			List<KeyValue> list()
			
				list()调用则把raw()中返回的数组转化为一个list()实例，并返回给用户，
				
				创建的List实例由原始返回结果中的KeyValue数组成员组成，用户可以方便地地带使用数据。
				
				
		另外还有一些面向列的存取函数如下：
		
			List<KeyValue> getColumn(byte [] family, byte [] qualifier)
			
			KeyValue getColumnLatest(byte []family, byte[] qualifire)
			
			boolean containColumn(byte[] family, byte [] qualifier)
			
				检查指定的列是否存在
			
			NavigableMap<byte[],byte[]> getFamilyMap(byte[] family)

				获取对应列族所包含的修饰符与值的键值对
				
			byte[] getValue(byte[] family, byte[] qualifier)

				获取对应列的最新值
		
		
	3.10 ResultScanner 类
	
		客户端获取值的接口
		
			void close()

				关闭scanner并释放分配给它的资源
			Result next()

				获取下一行的值
