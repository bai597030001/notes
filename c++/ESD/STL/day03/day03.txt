一、模板继承
在子类模板中直接访问那些依赖于模板参数的基类模板的成员，编译器在第一次编译时，通常会因为基类类型不明确而只在子类和全局作用域中搜索所引用的符号。
在子类模板中可以通过作用域限定符“::”，或者显式使用this指针，迫使编译器到基类中搜索所引用的符号。
二、模板型模板成员
1.模板型成员变量
类模板的成员变量，如果其类型又源自一个类模板的实例化类，那么它就是一个模板型模板成员变量。
2.模板型成员函数
类模板的成员函数，如果除了类模板的模板参数以外，还需要其它的模板参数，那么它就是模板型模板成员函数。
3.模板型成员模板
类模板的成员类型，如果除了类模板的模板参数以外，还需要其它的模板参数，那么它就是模板型模板成员模板。
三、模板型模板参数
类模板的模板参数除了可以接收具体类型以外，也可以接收模板，但是用于接收模板的模板参数不能用typename修饰，而必须使用下面的语法：
template<模板形参表> class 模板型模板参数名
模板形参表中的参数名可以省略不写。
模板型模板参数也可以带有缺省值。
四、零初始化
T t = T ();
无论T是类类型还是基本类型，t的初始值都是确定的。
如果T是类类型，t用相应类型的缺省构造函数初始化。
如果T是基本类型，t用相应类型的零初始化。
五、模板与虚函数
1.类模板的普通成员函数可以是虚函数，即可以为类模板定义虚成员函数。和普通的虚成员函数一样，类模板的虚成员函数亦可表现出多态性。
2.无论是类还是类模板，其虚成员函数都不能是模板函数。基于虚函数的多态机制，需要一个名为虚函数表的函数指针数组。该数组在类被编译或类模板被实例化的过程中产生，而此时那些模板形式的成员函数尚未被实例化，其入口地址和重载版本的个数，要等到编译器处理完对该函数的所有调用以后才能确定。成员函数模板的延迟编译阻碍了虚函数表的静态构建。
六、模板的编译模型
1.包含模型
1)通过将模板定义文件包含在模板声明文件中，使得包含该声明的编译单元同时满足，模板声明、定义和实例化俱可见的条件，令编译器能够正确地进行二次编译以产生指令代码
2)延长编译时间，模板的实现必须公开。
3)所有的C++编译器都支持包含模型。
2.显式实例化
1)在模板的实现文件中通过如下语法显式实例化模板：
template 返回类型 函数模板名<模板实参表> (形参表);
template class 类模板名<模板实参表>;
强制编译器在编译模板定义单元时，做二次编译生成与给定具体类型相应的具体实例，满足后期链接的需要。
2)编译速度快，模板的实现不必公开。
3)实例化所针对的类型总是有限的，不可能支持用户所有可能用到类型。
3.导出模型
1)通过在模板声明的template关键字前面加上export关键字，表示该模板为导出。编译器就会对该模板在一次编译以后所形成的内部表示进行缓存。当编译器编译实例化该模板的代码时，就会用实例化过程所指定的模板实参结合缓存中的内部表示，以完成该模板的第二次编译，生成指令代码，完成链接。
2)编译速度快，模板的实现不必公开。
3)目前绝大多数编译并不支持export关键字。C++2011中已将该关键字挪作它用。
七、预编译头文件
gcc -c xxx.h -> xxx.h.gch
xxx.c
#include "xxx.h" <- xxx.h.gch
stdafx.h
stdafx.cpp -> <project>.pch
#include "stdafx.h"
八、静态多态
将同一个操作作用相同的类型，却可以产生不同的结果，谓之多态。基于虚函数的多态通常被称为动态多态，而基于模板的多态则被称为静态多态。相对于前者，静态多态具有更好的时间性能，而且代码更加简洁，类型的层次也更简单，但是空间性能和灵活性较前者略差。
九、迷你模板库
包含一个容器，一个迭代器，一个泛型算法。
案例：双向线性链表容器
容器模板名：List
1.构造函数、析构函数、支持深拷贝的拷贝构造和拷贝赋值
2.获取首元素(front)、压入(push_front)和弹出(pop_front)首元素
3.获取尾元素(back)，压入(push_back)和弹出(pop_back)尾元素
4.删除所有匹配元素(remove)
5.清空(clear)、判断是否空(empty)、获取大小(size)
6.支持向输出流的插入运算
7.遍历元素(...)