 短整数数据类型也是一种数据类型，它里面包含了65536个不同的整数，其中一半是负数一半是非负数 
 
 短整数类型名称是short

 无符号短整数也是一种数据类型，他的名字是unsigned short

 这个类型中同样包含了65536个不同的整数，他们的范围从0到65535

 长整数也是一种数据类型，他的名字时long或者long int 

 这个类型里包含了2的32次方个不同的整数

 这些整数以0为中心向两边扩展，一半是负数，一半是非负数 

 无符号长整数也是一种数据类型，用unsigned long或者unsigned long int表示

 他里面同样包含2的32次方个不同的整数，从0开始向整数方向扩展

 整数类型用int表示，在我们的计算机上他和长整数类型一样

 无符号整数类型用unsigned int表示，在我们的计算机上他和无符号长整数类型一样

 所有包含整数的类型中数字范围是互相重叠的

 他们的数字范围是逐渐扩大的

 程序中所有不带小数点的数字计算机默认她的类型是整数类型

 在不带小数点的数字后加u表示这个数字的类型是无符号整数类型

 

 c语言中使用浮点类型表示带小数点的数字，

 浮点类型分两种，一种叫但精度浮点类型，另外一种叫双精度浮点类型

 单精度浮点类型所能记录的小数点后面的数位少，双精度浮点类型所能记录的小数点后面的数位多

 单精度浮点类型名称是float
 双精度浮点类型的名称是double
 
 程序中带小数点的数字计算机默认他的类型时双精度浮点类型 

 如果在带小数点的数字后加上f则表示这个数字的类型是但精度浮点类型




 数据类型和占位符之间的对应关系
  
  char                 %c或者%hhd
  unsigned char        %c或者%hhu
       %c对应字符表示方式
       %hhd对应整数表示方式
       %hhu对应整数表示方式

  short                 %hd
  unsigned short        %hu
  long                  %ld
  unsigned long         %lu
  int                   %d
  unsigned int          %u
  float                 %f或者%g
  double                %lf或者%lg
        f会保留小数点后无效的0
        g不会保留


 %nd也可以作为占位符使用，其中n代表一个整数，这个占位符要求打印结果一共占n个位置 

 %-nd也可以作为占位符使用，其中n代表一个整数，这个占位符同样要求打印结果占n个位置，有效数据出现在左边 

 %0nd也可以作为占位符使用，其中n代表一个整数，这个占位符同样要求打印结果站n个位置，他把所有空位置填充成字符‘0’

 %n.mf可以作为占位符打印但精度浮点数，n和m分别代表一个整数，他要求打印结果一共占n个位置，其中小数点后面占m个位置
      #include<stdio.h>
      int main () {
      printf ("%d\n",7);
      printf ("%3d\n",7);
      printf ("%-3dabc\n",7);
      printf ("%04d\n",7);
      printf ("%7.2f\n",4.8f);
      return 0;
       }       
 

 不同类型的存储区中所包含的字节个数不同

 sizeof关键字可以用来计算一个数据类型或者一个存储区所包含的字节个数       vi 030.c


 所有数据类型所包含的字节个数如下
 char(unsigned char)              1个字节 
 short(unsigned short)            2个字节
 long(unsigned long)              4个字节
 int(unsigned int)                4个字节
 float                            4个字节 
 double                           8个字节

 任何可以当数字使用的内容都可以写在sizeof关键字的小括号里

 sizeof关键字小括号里对存储区内容的修改不会真正发生                                      **** 

     #include<stdio.h>
     int main () {
          int num = 0;
          short snum = 0;
          printf ("sizeof(num)是%d,sizeof(snum)是%d\n",sizeof(num),sizeof(snum));
          printf ("sizeof(2 + 3)是%D\n",sizeof(2 + 3));
          return 0;
          }  
  

 日常生活中采用十进制记录数字

 计算机里采用二进制记录数字（每个数位上只有0和1这两中可能，没有正负号和小数点） 

 计算机的每个字节可以分成八段，每段可以用来记录一个0或者1。这个结构决定了计算机只能采用二进制的方式记录数字

 一个数字既可以采用十进制方式表示，也可以采用二进制当时表示。不会因为采用不同的表示方式而导致数字本身发生变化

 可以把二进制表示数字的方式看成一副画，画的内容是以盒巧克力，可以用这副画表示这盒巧克力的价格

 数字的二进制表示方式中每个数位有一个编号，最右边数位的编号是0，向左依次递增 

 每个数位上的0或者1单独代表一个数字，0代表的就是0，1代表的是2的编号次方

 在二进制表示中两个相邻的1之间有倍数关系，左边的1代表的数字是右边1代表数字的两倍

 用二进制表示的非负整数符合上述规则

 不同表示方式进行计算时采用不同的规则
   二进制表示方式加1时要把最右边的所有连续的1都变成0，把最右边的0都变成1
   0110 1011
   0110 1100
           
 二进制转换成十进制的方法是把每个数位上的数字单独转换成十进制然后再相加

  0110 1010 = 2^6 + 2^5 + 2^3 + 2^1        
            =64 + 32 + 8 + 2  
            =106

  0011 1011 = 32+16+8+2+1=59
           
 从十进制转换成二进制的方法
  1.可以首先把十进制数字拆分成多个2的整数次方之和，然后把每个拆分结果单独转换成二进制，最后把  所有转换结果合并

  71 = 64 +4 + 2 + 1
     = 2^6 + 2^2 + 2^1 + 2^0
     = 0100 0000 + 0000 0100 + 0000 0010 + 0000 0001
     = 0100 0111

  113 = 64 + 32 + 16 + 1
      =0111 0001

  95 = 64 + 16 + 8 + 4 + 2 + 1 
     = 0101 1111

  87 = 64 +16 + 4 + 2 + 1
     = 0101 0111
  
  2.不停进行除以2取余的操作，把所有余数按照从后向前的顺序排解在一起就得到转换结果
  eg:
       101              **** ****    
       101              **** ***1
       50               0*** ***0
       25               00** ***1
       12               000* ***0
       6                0000 ***0
       3                0000 0**1
       1                0000 00*1
       0                0000 0000  
     转换结果是：  0110 0101 
               
         
       87      1        0101 0111           
       43      1         
       21      1
       10      0
        5      1
        2      0
        1      1 
        0      0
 
  采用刚才的方法计算得到的二进制叫做原码

  计算机里记录的所有二进制都是补码

  所有非负整数的原码和补码是一样的
 
  
  八进制也是一种表示数字的方式

 把一个数字的二进制表示方式从右向左每三个数字分成一组，然后把每组转换成一个0到7之间的数字，转换结果就是数字的八进制表示方式 

  0110 1010           01 101 010      八进制是152    

 可以在程序中使用八进制表示数字，所有以八进制方式表示的数字必须以0做开头      0152       ****

 可以使用%o作为占位符把一个整数的八进制表示形式打印在屏幕上（结果不是以0做开头）          ****
   
     printf("%d 0%o\n",0152,0152)          ****
 
  十六进制也是一种表示数字的方式

 十六进制表示方式是把二进制表示方式从右向左每四个数位分成一组，把每组转换成一个内容，得到的结果就是十六进制表示方式

 如果转换结果在0到9之间则可以直接用它来表示，如果转换结果在10到15之间则用英文字母a到f表示

    1100 1011              十六进制表示方式cb

 可以在程序中使用十六进制方式表示数字，  十六进制表示的数字必须以0x开头

 可以使用%x或%X做占位符把数字的十六进制表示方式打印在屏幕上

 %x做占位符的时候，打印的所有字母都是小写的
 %X                                大
 打印结果不是以0x做开头

   printf ("%d 0x%x 0X%X\n",0xcb,0xcb,0xcb);            *** 

  1  #include<stdio.h>
  2  int main () {
  3     int num = 152;
  4     printf ("num的八进制数是0%o\n",num);
  5     printf ("%d,0%o\n",0152,0152);
  6     printf ("0x%x\n",123);
  7     printf ("%d 0x%x 0X%X\n",0xcb,0xcb,0xcb);
  8     return 0;
  9 }

   


 -5                **** ****
  5                0000 0101
     

 1 0000 0000   - 0000 0101
 
 1111 1111 + 1 - 0000 0101

 1111 1111 - 0000 0101 + 1

 1111 1010 + 1
 
 1111 1011   =   -5                    ***********

               
 计算负整数的二进制分如下两步

 1.首先计算出相反非负数的二进制

 2.把第一步的计算结果每个数位变成相反内容然后在加1

 采用上述方法计算得到的结果直接就是负数的二进制补码，可以直接记录在字节里
 
 所有有符号类型中都有一个特殊的二进制补码，它的最左边数位时1，右边的所有为数都是0，这个二进制补码用来表示这个有符号类型里最小的整数。

  1 0000 0000                                                       ?????????????

    1000 0000 

 采用上述方法不但可以根据非负数的二进制计算出相反负数的二进制，也可以反过来根据负数的二进制计算出相反非负数的二进制
 
     -41的二进制补码

  41                     0010 1001

 求反结果                1101 0110
 
  再加1结果               1101 0111 



预习  
  1.二进制
  2.操作符

作业 
  1.编写程序把用户输入的1到127之间的某个整数转换成二进制并把转换结果打印在屏幕上（采用两中方法实现）  

#include<stdio.h>
int main () {
    int x = 0;
    int t = 2;
    int a1,a2,a3,a4,a5,a6,a7,a8,a,b,c,d,e,f,g; 
    printf ("请输入一个1到127之间的数");
    scanf ("%d", &x);
    a1 = x % t,a = x / t;
    a2 = a % t,b = a / t;
    a3 = b % t,c = b / t;
    a4 = c % t,d = c / t;
    a5 = d % t,e = d / t;
    a6 = e % t,f = e / t;
    a7 = f % t,g = f / t;
    a8 = g % t;
    printf ("%d%d%d%d%d%d%d%d\n",a8,a7,a6,a5,a4,a3,a2,a1);                
    return 0;
    }     


  1 #include<stdio.h>                                       ?????????????
  2 int main () {
  3     int num = 0,base = 128,two = 2;
  4     printf ("请输入一个数字");
  5     scanf ("%d", &num);
  6     printf ("转换结果是");
  7     printf("%d",num / base);
  8     num = num - num / base * base;
  9     base = base / two;
 10     printf ("%d",num / base);
 11     num = num - num / base * base;
 12     base = base / two;
 13     printf("%d",num / base);
 14     num = num - num / base * base;
 15     base = base / two;
 16     printf("%d",num / base);
 17     num = num - num / base * base;
 18     base = base / two;
 19     printf("%d",num / base);
 20     num = num - num / base * base;
 21     base = base / two;
 22     printf("%d",num / base);
 23     num = num - num / base * base;
24     base = base / two;
 25     printf("%d",num / base);
 26     num = num - num / base * base;
 27     base = base / two;
 28     printf("%d\n",num / base);
 29     num = num - num / base * base;
 30     base = base / two;
 31     return 0;
 32 }



  

  1  #include<stdio.h>                       ??????????????
  2 int main () {
  3     int num = 0,two = 2;
  4     printf ("请输入一个数字");
  5     scanf ("%d", &num);
  6     printf ("%9d\r",num - num / two * two);
  7     num = num / two;
  8     printf ("%8d\r",num - num / two * two);
  9     num = num / two;
 10     printf ("%7d\r",num - num / two * two);
 11     num = num / two;
 12     printf ("%6d\r",num - num / two * two);
 13     num = num / two;
 14     printf ("%4d\r",num - num / two * two);
 15     num = num / two;
 16     printf ("%3d\r",num - num / two * two);
 17     num = num / two;
 18     printf ("%2d\r",num - num / two * two);
 19     num = num / two;
 20     printf ("%d\n",num - num / two * two);
 21     num = num / two;
 22     return 0;
 23 }












  
