1. java中的匿名类用法

	匿名内部类也就是没有名字的内部类
	
	正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写
	
	但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口

	
	实例1:不使用匿名内部类来实现抽象方法
	
		abstract class Person {
			public abstract void eat();
		}
		 
		class Child extends Person {
			public void eat() {
				System.out.println("eat something");
			}
		}
		 
		public class Demo {
			public static void main(String[] args) {
				Person p = new Child();
				p.eat();
			}
		}

	我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用
	但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？
	这个时候就引入了匿名内部类
	
	
	实例2：匿名内部类的基本实现
	
		abstract class Person {
			public abstract void eat();
		}
		public class Demo {
			public static void main(String[] args) {
				Person p = new Person() {
					public void eat() {
						System.out.println("eat something");
					}
				};
				p.eat();
			}
		}
		
	可以看到，我们直接将抽象类Person中的方法在大括号中实现了
	这样便可以省略一个类的书写
	并且，匿名内部类还能用于接口上
	
	实例3：在接口上使用匿名内部类
	
		interface Person{
			public void eat();
		}
		 
		public class Demo{
			public static void main(String[] args) {
			
				Person p = new Person(){
					public void eat(){
						System.out.println("eat something");
					}
				};
				p.eat();
			}
		}
		
	由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现
	最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口
	
	实例4：Thread类的匿名内部类实现
	
		public class Demo{
			public static void main(String[] args) {
				Thread t = new Thread(){
					public void run(){
						for (int i = 1; i <= 5; i++) {
							System.out.print(i+ "");
						}
					}
				};
				t.start();
			}
		}
		
	实例5：Runnable接口的匿名内部类实现
	
		public class Demo {
			public static void main(String[] args) {
				Runnable r = new Runnable() {
					public void run() {
						for (int i = 1; i <= 5; i++) {
							System.out.print(i + " ");
						}
					}
				};
				Thread t = new Thread(r);
				t.start();
			}
		}
				
2. 使用匿名类采坑记录

	思考以下代码的输出是什么？
	Runnable x = new Runnable() {  
		@Override  
		public void run() {  
			System.out.println(this.getClass());  
		}  
	};  
	x.run();
	实际答案是出现xxxx$1这样一个类名，它是编译器给定的名称。
	
	
	在项目中,如果有这样的需求: 将mysql数据表中的某一张表存储到redis中缓存,
	每2周更新一次该缓存(即从mysql重新查询一次后序列化到redis)
	
	module:
	
		public class LineTrainRelateModule implements Serializable{
			private String trainNum;
			private int lineId;
			public String getTrainNum() {
				return trainNum;
			}
			public void setTrainNum(String trainNum) {
				this.trainNum = trainNum;
			}
			public int getLineId() {
				return lineId;
			}
			public void setLineId(int lineId) {
				this.lineId = lineId;
			}
		}

	
	rowmapper:
		
		rowmapper处用到了匿名类的写法,其返回类型其实是 LineTrainRelateModule$1 这样一个类名
		
		public class LineTrainRelateRowMapper implements RowMapper<LineTrainRelateModule> {
			@Override
			public LineTrainRelateModule mapRow(ResultSet resultSet, int i) throws SQLException {
				return new LineTrainRelateModule() {{
					module.setTrainNum(resultSet.getString("TrainNum"));
					module.setLineId(resultSet.getInt("LineId"));
				}}
			}
		}
		
	dao:
	
		@Repository
		public class LineTrainRelateDao {

			private static String TABLE_NAME = "mtLineTrainTable";

			@Autowired
			private RowMapper<LineTrainRelateModule> rowMapper;

			@Autowired
			@Qualifier("gbiapCommonConfigJdbcTemplate")
			private JdbcTemplate jdbcTemplate;

			public List<LineTrainRelateModule> getLineTrainRelate() {
				String sql = "select * from " + TABLE_NAME;
				return jdbcTemplate.query(sql, rowMapper);
			}
		}
	
	redis:
	
		public List<LineTrainRelateModule> getLineTrainRelate() {
			String key = Utility.MODULE_NAME + "_" + Utility.VERSION + "_"
					+ RedisConfig.TRAINNUM_LINE_KEY;
			List<LineTrainRelateModule> list = (List<LineTrainRelateModule>)
					jdkRedisTemplate.opsForValue().get(key);
			if(list == null || list.isEmpty()) {
				List<LineTrainRelateModule> lineTrainRelate =
						lineTrainRelateDao.getLineTrainRelate();
				if(lineTrainRelate == null || lineTrainRelate.isEmpty()) {
					logger.error("no data in" + RedisConfig.TRAINNUM_LINE_KEY);
					return null;
				}
				jdkRedisTemplate.opsForValue().set(key, lineTrainRelate,
						RedisConfig.CONFIG_EXPIRE_TIME_SECONDS, TimeUnit.SECONDS);
				return lineTrainRelate;
			}
			return list;
		}

	其中 rowMapper 中用到了匿名类的写法,所以其返回的就是 LineTrainRelateModule$1 这样一个类名
	导致 dao 层的 getLineTrainRelate() 方法返回的list元素类型也是  LineTrainRelateModule$1 类型。
	
	如果直接从mysql查询(即: 直接调用 dao 层getLineTrainRelate()方法)没有任何问题。
	
	但是此处如果将 dao 层的 getLineTrainRelate() 方法返回的list存储到 redis 后,其序列化到redis中的
	类型为 LineTrainRelateModule$1 ; 当从 redis 中get 该list 时,则会出现类型转换错误、序列化/反序列化错误.
	
	其根本原因,就是 rowmapper 处 匿名类返回类型的问题
	
	->改正:
		
		public class LineTrainRelateRowMapper implements RowMapper<LineTrainRelateModule> {
			@Override
			public LineTrainRelateModule mapRow(ResultSet resultSet, int i) throws SQLException {
				LineTrainRelateModule module = new LineTrainRelateModule();
				module.setTrainNum(resultSet.getString("TrainNum"));
				module.setLineId(resultSet.getInt("LineId"));
				return module;
			}
		}
