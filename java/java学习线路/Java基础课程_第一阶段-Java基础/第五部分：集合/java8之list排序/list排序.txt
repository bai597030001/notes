https://www.cnblogs.com/tomyLi/p/JAVA8rang-dai-ma-geng-you-ya-zhiList-pai-xu.html
https://blog.csdn.net/huangshulang1234/article/details/79136981

JAVA8-让代码更优雅之List排序 

	List<User> list = initList();
	
	private static List<User> initList() {
        List<User> list = new ArrayList<>();
        list.add(new User("lisa", 23));
        list.add(new User("tom", 11));
        list.add(new User("john", 16));
        list.add(new User("jennis", 26));
        list.add(new User("tin", 26));
        list.add(new User("army", 26));
        list.add(new User("mack", 19));
        list.add(new User("jobs", 65));
        return list;
    }


	1. jdk8之前的排序
	
		Collections.sort(list, new Comparator<User>() {
			@Override
			public int compare(User o1, User o2) {
				return o1.getAge().compareTo(o2.getAge());
			}
		});
		
		eg:
		Collections.sort(humans, new Comparator<Human>() {
		   public int compare(Human h1, Human h2) {
			   return h1.getName().compareTo(h2.getName());
		   }
	   });

		
	2. jdk8 lambda排序，带参数类型
	
		list.sort((User u1, User u2) -> u1.getAge().compareTo(u2.getAge()));
		
	3. jdk8 lambda排序，不带参数类型
	
		 list.sort((u1, u2) -> u1.getAge().compareTo(u2.getAge()));
		 
	4. jdk8 排序，User类静态方法引用
	
		 list.sort(User::compareAge);
		 
	5.  jdk8 升序排序， Comparator 提供的静态方法
	
		Collections.sort(list, Comparator.comparing(User::getAge));
		
	6.  jdk8 降序排序， Comparator 提供的静态方法
	
		Collections.sort(list, Comparator.comparing(User::getAge).reversed());
		
	7. jdk8 组合排序， Comparator 提供的静态方法，先按年纪排序，年纪相同的按名称排序
		
		 Collections.sort(list, Comparator.comparing(User::getAge).thenComparing(User::getName));
		 
	---------------------------------------------------------------------------------------------------------
	
		Comparator<Map<String, String>> comparable = (m1, m2) ->
            Integer.parseInt(m1.get("kilometer")) > Integer.parseInt(m2.get("kilometer")) ? 0 : -1;
        comparable.thenComparing((m1, m2) ->
                Integer.parseInt(m1.get("timeMs")) > Integer.parseInt(m2.get("timeMs")) ? 0 : -1);
 
	->
	
		Comparator<Map<String, String>> comparable = (m1, m2) ->
            Integer.parseInt(m1.get("kilometer")) - Integer.parseInt(m2.get("kilometer"));
        comparable.thenComparing((m1, m2) ->
                Integer.parseInt(m1.get("timeMs")) - Integer.parseInt(m2.get("timeMs")));

	->
	
		Comparator<Map<String, String>> comparable = Comparator.comparingInt(m -> Integer.parseInt(m.get("kilometer")));
        comparable.thenComparing(Comparator.comparingInt(m -> Integer.parseInt(m.get("kilometer"))));

	->
	
		Comparator<Map<String, String>> comparable = Comparator.comparingInt((Map<String, String> m) -> Integer.parseInt(m.get("kilometer")))
        .thenComparing(Comparator.comparingInt((Map<String, String> m) -> Integer.parseInt(m.get("kilometer"))));

	->
		 
		beforeList.sort(Comparator.comparingInt((Map<String, String> m) -> Integer.parseInt(m.get("kilometer")))
		.thenComparing(Comparator.comparingInt(m -> Integer.parseInt(m.get("timeMs")))));
