Java 8 中的 Streams API 详解

https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/


1. 有多种方式生成 Stream Source：

	从 Collection 和数组
		
		Collection.stream()
		
		Collection.parallelStream()
		
		Arrays.stream(T array) or Stream.of()
	
	从 BufferedReader
		
		java.io.BufferedReader.lines()
	
	静态工厂
		
		java.util.stream.IntStream.range()
		
		java.nio.file.Files.walk()
	
	自己构建
		
		java.util.Spliterator
	
	其它
	
		Random.ints()
		
		BitSet.stream()
		
		Pattern.splitAsStream(java.lang.CharSequence)
		
		JarFile.stream()
		
2. 流的操作类型分为两种：

	Intermediate ：一个流可以后面跟随零个或多个 intermediate 操作。
				
				其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。
				
				这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。
	
	Terminal ：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。
		
				所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，
				
				并且会生成一个结果，或者一个 side effect。
				
				
	还有一种操作被称为 short-circuiting。用以指：

		对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。
		
		对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。
		
		当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。
		
3. 流的使用详解

	简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。
	
	
	3.1 流的构造与转换
	
		// 1. Individual values
			
			Stream stream = Stream.of("a", "b", "c");
		
		// 2. Arrays
		
			String [] strArray = new String[] {"a", "b", "c"};
			
			stream = Stream.of(strArray);
		
			stream = Arrays.stream(strArray);
		
		// 3. Collections
		
			List<String> list = Arrays.asList(strArray);
		
			stream = list.stream();
			
		对于基本数值型，目前有三种对应的包装类型 Stream ：
		
			IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<Integer>、Stream<Long> >、
			
			Stream<Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。
			
		Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。
		而常规的数值型聚合运算可以通过上面三种 Stream 进行。
		
		
		数值流的构造
		
			IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);
			
			IntStream.range(1, 3).forEach(System.out::println);
			
			IntStream.rangeClosed(1, 3).forEach(System.out::println);
			
		 流转换为其它数据结构
		 
			// 1. Array
				
				String[] strArray1 = stream.toArray(String[]::new);
			
			// 2. Collection
				
				List<String> list1 = stream.collect(Collectors.toList());
				
				List<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));
				
				Set set1 = stream.collect(Collectors.toSet());
				
				Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
			
			// 3. String
				
				String str = stream.collect(Collectors.joining()).toString();
				
	3.2 流的操作
	
		Intermediate：
			
			map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 

			limit、 skip、 parallel、 sequential、 unordered

		Terminal：
			
			forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 
			
			count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator

		Short-circuiting：

			anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit
			
			
		我们下面看一下 Stream 的比较典型用法。
		
			map/flatMap:
			
				它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。
				
				eg: 转换大写
				
					List<String> output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList());
					
					平方数
					
					List<Integer> nums = Arrays.asList(1, 2, 3, 4);
					List<Integer> squareNums = nums.stream().map(n -> n * n).collect(Collectors.toList());
					
				从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。
				还有一些场景，是一对多映射关系的，这时需要 flatMap。
				
				一对多
				
					Stream<List<Integer>> inputStream = Stream.of(Arrays.asList(1),Arrays.asList(2, 3),Arrays.asList(4, 5, 6));
					Stream<Integer> outputStream = inputStream.flatMap((childList) -> childList.stream());
					
					flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，
					最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。
					
			filter:
				
				filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。
				
				eg: 留下偶数
				
					Integer[] sixNums = {1, 2, 3, 4, 5, 6};
					Integer[] evens = Stream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);
					
					把单词挑出来
					
					List<String> output = reader.lines().
					flatMap(line -> Stream.of(line.split(REGEXP))).
					filter(word -> word.length() > 0).
					collect(Collectors.toList());
					
					这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。
					
			forEach:
				
				forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。
				
				eg: 打印姓名
				
					// Java 8
					roster.stream()
					 .filter(p -> p.getGender() == Person.Sex.MALE)
					 .forEach(p -> System.out.println(p.getName()));
					// Pre-Java 8
					for (Person p : roster) {
					 if (p.getGender() == Person.Sex.MALE) {
					 System.out.println(p.getName());
					 }
					}
					
				一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。
				
				forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。
				
				当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，
				并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 
				for 循环 code 可能需要加入额外的多线程逻辑。
				
				另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，
				你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：
				
					stream.forEach(element -> doOneThing(element));
					stream.forEach(element -> doAnotherThing(element));
					
				相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。
				
					peek 对每个元素执行操作并返回一个新的 Stream
					
					Stream.of("one", "two", "three", "four")
					 .filter(e -> e.length() > 3)
					 .peek(e -> System.out.println("Filtered value: " + e))
					 .map(String::toUpperCase)
					 .peek(e -> System.out.println("Mapped value: " + e))
					 .collect(Collectors.toList());
			
			
			findFirst:
				
				这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。
				
					这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，
					
					作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。
					
					
					Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。
					
					还有例如 IntStream.average() 返回 OptionalDouble 等等。
					
			reduce:
			
				这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），
				
				然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。
				
				从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。
				
				例如 Stream 的 sum 就相当于

					Integer sum = integers.reduce(0, (a, b) -> a+b); 或

					Integer sum = integers.reduce(0, Integer::sum);

				也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。
				
				
				reduce 的用例
				
					// 字符串连接，concat = "ABCD"
						
						String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); 
					
					// 求最小值，minValue = -3.0
						
						double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); 
					
					// 求和，sumValue = 10, 有起始值
						
						int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
					
					// 求和，sumValue = 10, 无起始值
						
						sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();
					
					// 过滤，字符串连接，concat = "ace"
						concat = Stream.of("a", "B", "c", "D", "e", "F").
						filter(x -> x.compareTo("Z") > 0).
						reduce("", String::concat);
						
					上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，
					第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。
					而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。