每个存储区都是有主人的

存储区的主人一定是某一组语句的执行过程

存储区的主人只能在某个时间范围内存在

只有存储区的主人存在的时间范围内存储区才是可以使用的

这个时间范围叫做存储区的生命周期

只有存储区的主人所包含的语句才可以使用存储区对应的变量           ****

这些语句叫做这个存储区的作用域

作用域之外的语句不可以使用存储区对应的变量，但是也许可以使用存储区本身



如果一个变量声明在所有大括号的外边，这种变量叫做全局变量

全局变量的主人是程序中所有语句的一次执行过程

全局变量的生命周期时整个程序的执行时间范围

全局变量的作用域是整个程序中的所有语句

没有初始化的全局变量自动初始化成0


如果一个变量被声明在一个函数的大括号里则他叫做局部变量

局部变量的主人是函数内部的所有语句的一次执行过程

局部变量的生命周期是他所在的函数某一次执行的时间范围

局部变量的作用域是他所在函数内部的所有语句


函数内部某个大括号里的所有语句叫做一个语句块

声明在语句块里面的变量叫做块变量

块变量的主人是语句块的一次执行过程

块变量的生命周期时语句块某次执行的时间范围

块变量的作用域是语句块内部的所有语句


声明变量时尽量选择作用域小的变量类型

在一个程序中不同种类的变量可以重名

如果一条语句中使用了重名变量则计算机会选择可用变量中作用域最小的那个

/*
   重名变量演示
   */
#include <stdio.h>
int num;
int main() {
	printf("num是%d\n", num);
	int num = 1;
	printf("num是%d\n", num);
	{
	    printf("num是%d\n", num);
		int num = 2;
	    printf("num是%d\n", num);
	}
	printf("num是%d\n", num);
	return 0;
}



程序在内存中是分段落保存的

代码段        记录程序语句转换得到的数字                 在程序运行时候不可以修改

全局段        用来记录主人时整个程序运行的所有存储区      所包含的字节个数不会随着程序的运行而改变

栈           用来记录局部变量，块变量，形式参数和返回值的存储区    所包含的字节个数会随着程序的运行而改变
                                                                 每当一个心函数开始运行这个段落中就多处一些字节节，                                                               这写字节组成这个心函数所需要的所有存储区 
                                                               
                                                                 每当一个函数结束执行他所占有的所有字节就被回收了


                                                                 如果函数A在函数B之前开始运行则 必须先回收函数B所占有的字节然后才能回收函数A所占有的字节  



堆            包含动态分配的存储区                               堆中能包含的字节个数几乎可以认为是无限的

                                                                堆里面存储区的生命周期由程序员来管理  





声明变量时可以使用关键字

1.auto关键字用来声明自动变量。         所有局部变量都是自动变量，不需要使用这个关键字

2.static关键字用来声明静态变量。       全局变量，局部变量和块变量都可以变成静态变量，所有静态变量的主人都是整个程序的运行过程（所有静态变量的生命周期是整个程序的运行时间，作用域和非静态变量一致）

静态全局变量的作用域是声明他的那个文件中的所有语句

没有初始化的静态变量自动初始化成0

静态变量的初始化只在程序开始时执行一次----------------------

/*
   静态变量演示
   */
#include <stdio.h>
void func(void) {
	static int num = 10;
	printf("num是%d\n", num);
	num = 3;
}
void func1(void) {
	int num = 10;
	int num1 = 11;
	int num2 = num + num1;
}
int main() {
    func();
	func1();
	func();
	return 0;
}

3.const关键字可以用来声明不可以赋值的变量

这种变量只能在初始化的时候往里边放数字

/*
   const演示
   */
#include <stdio.h>
int main() {
	const int num = 0;
	//num = 10;   错误
	printf("请输入一个数字：");
	scanf("%d", &num);
	printf("num是%d\n", num);
	return 0;
}


4.volatile关键字可以涌来声明多变的变量            *****************

只要是等待别的程序修改某个变量的话，就加上volatile关键字。





指针类型也是一种数据类型，可以用它来声明变量

指针类型变量用来记录地址数据

一但指针中记录了一个有效地址数据就可以根据指针找到地址所属的那个存储区

指针变量类似一个种子文件

指针变量和种子文件的区别

1.指针变量任何时候最多只能帮忙找到另外一个存储区

2.指针变量的内容可以改变，在不同的时候指针变量可以帮忙找到不同的其他存储区

  不同类型存储区地址适合记录在不同类型的指针变量中

演示指针的基本使用

  1 #include<stdio.h>
  2 int main () {
  3     int num = 0;
  4     int *p_num = &num;                //把num变量地址初始给指针变量
  5     *p_num = 10;
  6     printf ("num是%d\n",num);
  7     return 0;
  8 }


只有捆绑过的指针才可以用来表示另外一个存储区


指针变量可以在程序中代表4个不同的内容                                       **********

1.指针变量名称可以涌来代表指针自己的存储区或者这个存储区里的地址数据

2.指针变量名称前加*可以用来代表捆绑存储区或者捆绑存储区里的数据

  1 #include<stdio.h>
  2 int main () {
  3     int num = 0;
  4     int *p_num = &num;  //把num变量地址初始给指针变量
  5     *p_num = 10;
  6     printf ("num是%d\n",num);
  7     printf ("p_num是%p\n",p_num);                ***
  8     printf ("*p_num是%d\n",*p_num);              ***
  9     return 0;
 10 }


NULL叫做空地址，他的数值就是数字0

没有捆绑过的指针必须记录空地址，这种指针叫做空指针

因为所有捆绑过的指针一定不会是空指针，所以可以把空指针和捆绑过的指针区分开

既没有捆绑过也不是空指针的指针叫做野指针

程序中禁止出现野指针

没有初始化的指针都是野指针，所有指针变量都应该初始化

特别注意 ： 指针变量初始化的时候*没有参与赋值过程，被赋值的是指针本身的存储区  ****


演示：
    1.从键盘得到三个整数，把其中最大整数打印在屏幕上（使用指针实现）----------------

  1 #include<stdio.h>
  2 int main () {
  3     int num = 0,num1 = 0,num2 = 0;
  4     int *p_num = &num;
  5     int *p_num1 = &num1;
  6     int *p_num2 = &num2;
  7     printf ("请输入三个数字");
  8     scanf("%d%d%d",p_num,p_num1,p_num2);
  9     if (*p_num > *p_num1 && *p_num > *p_num2) {
 10         printf ("最大数字时%d\n",*p_num);
 11     }
 12     else if (*p_num1 > *p_num && *p_num1 > *p_num2) {
 13         printf ("最大数是%d\n",*p_num1);
 14     }
 15     else {
 16         printf ("最大数是%d\n",*p_num2);
 17     }
 18     return 0;
 19 }

   
       
可以在一条语句中声明多个同类型的指针变量，这个时候要在每个指针变量名称前加*


指针的变量内容可以改变，可以让一个指针在不同的时候和不同的存储区捆绑

练习：
    1.修改刚才的演示程序                    -------------------------------

/*
   指针练习                                      ????????????????
   */
#include <stdio.h>
int main() {
	int num = 0, num1 = 0, num2 = 0;
	int *p_max = &num, *p_mid = &num1, *p_min = *num2, *p_tmp = NULL;
	if (*p_max < *p_mid) {
		p_tmp = p_max;
		p_max = p_mid;
		p_mid = p_tmp;
	}
	if (*p_max < *p_min) {
		p_tmp = p_max;
		p_max = p_min;
		p_min = p_tmp;
	}
	if (*p_min > *p_mid) {
		p_tmp = p_mid;
		p_mid = p_min;
		p_min = p_tmp;
	}
	printf("%d %d %d\n", *p_max, *p_mid, *p_min);
	return 0;
}


在使用指针的时候往往不知道捆绑存储区的来源，而只知道他的某种使用特征

所有类型的指针变量大小一样

在我们的计算机上所有指针变量的大小都是四个字节

  1 #include<stdio.h>
  2 int main () {
  3     int *p_num = NULL;
  4     char *p_ch = NULL;
  5     printf ("%d,%d\n",sizeof(p_num),sizeof(p_ch));
  6     return 0;
  7 }
  8 

不同类型指针之间互相赋值不会导致地址数据丢失（大小一样）

通过指针找到的捆绑存储区类型由指针类型决定

可以把一个指针强制类型转换成其他类型的指针，通过转换后的指针得到的捆绑存储区类型也会随之改变

利用指针强制类型转换可以把一个类型的存储区当作另外一个类型的存储区使用

/*
   指针演示                                                            kan kanknak kank nkank aknkan 
   */
#include <stdio.h>
int main() {
	int num = 300;
	int *p_num = &num;
	char *p_ch = p_num;                                              ??????????????
	printf("sizeof(p_num)是%d,sizeof(p_ch)是%d\n", sizeof(p_num), sizeof(p_ch));
	printf("p_num是%p,p_ch是%p\n", p_num, p_ch);
	printf("*p_num是%d,*p_ch是%d\n", *p_num, *p_ch);
	printf("*(char *)p_num是%d\n", *(char *)p_num);                  *************
	return 0;
}



无类型指针没有表示捆绑存储区的类型

无类型指针用void *表示

这种类型的指针可以和任何存储区捆绑

不可以直接在无类型指针前加*，必须要首先强制类型转换成有类型指针然后才可以加*

无类型指针可以用来记录来源不明并且类型可能又很多的地址数据

  1 #include<stdio.h>
  2 int main () {
  3     int num = 10;
  4     char ch = 100;
  5     void *p_v = &num;
  6     *(int *)p_v = 50;                            ????????????
  7     p_v = &ch;
  8     *(char *)p_v = 5;
  9     return 0;
 10 }




预习：
    1.指针
    2.字符串

作业
    1.使用指针编写程序交换两个整数变量的内容
    2.把1.0f的二进制内容以十六进制的方式打印在屏幕上


  1 #include<stdio.h>
  2 int main () { 
  3     int num = 0,num1 = 0,tmp = 0;
  4     int *p_num = &num,*p_num1 = &num1,*p_tmp = &tmp;
  5     printf ("请输入两个书");
  6     scanf("%d%d",p_num,p_num1);
  7     *p_tmp = *p_num;
  8     *p_num = *p_num1;
  9     *p_num1 = *p_tmp;
 10     printf ("num是%d,num1是%d\n",*p_num,*p_num1);
 11     return 0;
 12 }



  1 #include<stdio.h>
  2 int main () {
  3     float fnum = 1.0f;
  4     printf ("转换结果是0x%x\n",*(int *)&fnum);               ????????
  5     return 0;
  6 }















      
























 
