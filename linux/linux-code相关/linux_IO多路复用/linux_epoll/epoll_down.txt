 Linux中epoll用法小结 2011-01-10 18:01:33

分类： C/C++

epoll是Linux内核为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，
它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。

一、epoll的优点

支持一个进程打开大数目的socket描述符。

IO效率不随FD数目增加而线性下降。

内核微调。

二、epoll的使用

epoll有2种工作方式：LT和ET。 　　

LT（level triggered，水平触发）是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，
内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，
所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。 　　

ET （edge-triggered，边缘触发）是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，
内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，
直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，
或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。
但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。

epoll相关的系统调用有3个：epoll_create, epoll_ctl和epoll_wait。在头文件

1. int epoll_create(int size);

参数size：用来告诉内核要监听的数目一共有多少个。

返回值：成功时，返回一个非负整数的文件描述符，作为创建好的epoll句柄。调用失败时，返回-1，错误信息可以通过errno获得。
    说明：创建一个epoll句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，
	给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，所以在使用完epoll后，必须调用close()关闭，
	否则可能导致fd被耗尽。

2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    参数epfd：epoll_create()函数返回的epoll句柄。

参数op：操作选项。

参数fd：要进行操作的目标文件描述符。

参数event：struct epoll_event结构指针，将fd和要进行的操作关联起来。

返回值：成功时，返回0，作为创建好的epoll句柄。调用失败时，返回-1，错误信息可以通过errno获得。

说明：epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。

参数op的可选值有以下3个：
EPOLL_CTL_ADD：注册新的fd到epfd中；
EPOLL_CTL_MOD：修改已经注册的fd的监听事件；
EPOLL_CTL_DEL：从epfd中删除一个fd；
struct epoll_event结构如下：

    typedef union epoll_data {  
       void *ptr;  
       int fd;  
       __uint32_t u32;  
       __uint64_t u64;  
    } epoll_data_t;  
      
    struct epoll_event {  
       __uint32_t events; /* Epoll events */  
       epoll_data_t data; /* User data variable */  
    };  

   events可以是以下几个宏的集合：
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
    参数epfd：epoll_create()函数返回的epoll句柄。

参数events：struct epoll_event结构指针，用来从内核得到事件的集合。

参数 maxevents：告诉内核这个events有多大

参数 timeout: 等待时的超时时间，以毫秒为单位。

返回值：成功时，返回需要处理的事件数目。调用失败时，返回0，表示等待超时。

说明：等待事件的产生。

三、示例

    /* 
    使用 epoll 写的回射服务器 
    将从client中接收到的数据再返回给client 
     
    */  
    #include   
    #include   
    #include   
    #include   
    #include   
    #include   
    #include   
    #include   
    #include   
      
    using namespace std;  
      
    #define MAXLINE 100  
    #define OPEN_MAX 100  
    #define LISTENQ 20  
    #define SERV_PORT 5000  
    #define INFTIM 1000  
      
    void setnonblocking(int sock)  
    {  
        int opts;  
         opts=fcntl(sock,F_GETFL);  
        if(opts<0)  
        {  
            perror("fcntl(sock,GETFL)");  
            exit(1);  
        }  
         opts = opts|O_NONBLOCK;  
        if(fcntl(sock,F_SETFL,opts)<0)  
        {  
            perror("fcntl(sock,SETFL,opts)");  
            exit(1);  
        }  
    }  
      
    int main(int argc, char* argv[])  
    {  
        int i, maxi, listenfd, connfd, sockfd,epfd,nfds, portnumber;  
        ssize_t n;  
        char line[MAXLINE];  
        socklen_t clilen;  
        string szTemp("");  
      
        if ( 2 == argc )  
        {  
            if( (portnumber = atoi(argv[1])) < 0 )  
            {  
                fprintf(stderr,"Usage:%s portnumber\a\n",argv[0]);  
                return 1;  
            }  
        }  
        else  
        {  
            fprintf(stderr,"Usage:%s portnumber\a\n",argv[0]);  
            return 1;  
        }  
      
      
      
        //声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件  
        struct epoll_event ev, events[20];  
          
        //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大  
        epfd = epoll_create(256); //生成用于处理accept的epoll专用的文件描述符  
          
        struct sockaddr_in clientaddr;  
        struct sockaddr_in serveraddr;  
        listenfd = socket(AF_INET, SOCK_STREAM, 0);  
          
        //把socket设置为非阻塞方式  
        //setnonblocking(listenfd);  
      
        //设置与要处理的事件相关的文件描述符  
        ev.data.fd=listenfd;  
          
        //设置要处理的事件类型  
        ev.events=EPOLLIN|EPOLLET;  
      
        //注册epoll事件  
        epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&ev);  
          
        bzero(&serveraddr, sizeof(serveraddr)); /*配置Server socket的相关信息 */  
        serveraddr.sin_family = AF_INET;  
        char *local_addr="127.0.0.1";  
        inet_aton(local_addr,&(serveraddr.sin_addr));//htons(portnumber);  
        serveraddr.sin_port=htons(portnumber);  
        bind(listenfd,(sockaddr *)&serveraddr, sizeof(serveraddr));  
          
        listen(listenfd, LISTENQ);  
          
        maxi = 0;  
          
        for ( ; ; ) {  
              
            //等待epoll事件的发生  
            //返回需要处理的事件数目nfds，如返回0表示已超时。  
            nfds=epoll_wait(epfd,events,20,500);  
              
            //处理所发生的所有事件  
            for(i=0; i < nfds; ++i)  
            {  
                //如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。  
                if(events[i].data.fd == listenfd)  
                {  
                    connfd = accept(listenfd,(sockaddr *)&clientaddr, &clilen);  
                    if(connfd < 0)  
                    {  
                        perror("connfd < 0");  
                        exit(1);  
                    }  
                    //setnonblocking(connfd);  
                    char *str = inet_ntoa(clientaddr.sin_addr);  
                    cout << "accapt a connection from " << str << endl;  
                      
                    //设置用于读操作的文件描述符  
                      ev.data.fd=connfd;  
                      
                    //设置用于注册的读操作事件  
                      ev.events=EPOLLIN|EPOLLET;  
      
                    //注册ev  
                    epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&ev); /* 添加 */  
                }  
                //如果是已经连接的用户，并且收到数据，那么进行读入。  
                else if(events[i].events&EPOLLIN)  
                {  
                    cout << "EPOLLIN" << endl;  
                    if ( (sockfd = events[i].data.fd) < 0)  
                        continue;  
                    if ( (n = recv(sockfd, line, sizeof(line), 0)) < 0)   
                    {    
                        // Connection Reset:你连接的那一端已经断开了，而你却还试着在对方已断开的socketfd上读写数据！  
                        if (errno == ECONNRESET)  
                        {  
                            close(sockfd);  
                            events[i].data.fd = -1;  
                        }   
                        else  
                            std::cout<<"readline error"<
                    }   
                    else if (n == 0) //读入的数据为空  
                    {  
                        close(sockfd);  
                        events[i].data.fd = -1;  
                    }  
                      
                    szTemp = "";  
                    szTemp += line;  
                    szTemp = szTemp.substr(0,szTemp.find('\r')); /* remove the enter key */  
                    memset(line,0,100); /* clear the buffer */  
                    //line[n] = '\0';  
                    cout << "Readin: " << szTemp << endl;  
                      
                    //设置用于写操作的文件描述符  
                    ev.data.fd=sockfd;  
                      
                    //设置用于注册的写操作事件  
                    ev.events=EPOLLOUT|EPOLLET;  
                      
                    //修改sockfd上要处理的事件为EPOLLOUT  
                    epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev); /* 修改 */  
      
                }  
                else if(events[i].events&EPOLLOUT) // 如果有数据发送  
      
                {  
                    sockfd = events[i].data.fd;  
                    szTemp = "Server:" + szTemp + "\n";  
                    send(sockfd, szTemp.c_str(), szTemp.size(), 0);  
                      
                      
                    //设置用于读操作的文件描述符  
                    ev.data.fd=sockfd;  
                     
                    //设置用于注册的读操作事件  
                    ev.events=EPOLLIN|EPOLLET;  
                      
                    //修改sockfd上要处理的事件为EPOLIN  
                    epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev); /* 修改 */  
                }  
            } //(over)处理所发生的所有事件  
        } //(over)等待epoll事件的发生  
          
        close(epfd);  
        return 0;  
    }  