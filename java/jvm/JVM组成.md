# JVM的组成

1.  类加载器（ClassLoader）  
2.  运行时数据区（Runtime Data Area）  
3.  执行引擎（Execution Engine）  
4.  本地库接口（Native Interface）  

## 作用

程序在执行之前先要把java代码转换成字节码（class文件），jvm首先需要把字节码通过一定的方式 **类加载器（ClassLoader）** 把文件加载到内存中 **运行时数据区（Runtime Data Area）** ，而字节码文件是jvm的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器 **执行引擎（Execution Engine）** 将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口 **本地库接口（Native Interface）**来实现整个程序的功能，这就是这4个主要组成部分的职责与功能。



类加载器

> 将.class字节码文件加载到内存（运行时数据区）

运行时数据区

> 

 执行引擎

> 将.class字节码文件转换成底层操作系统指令，再交给CPU执行

本地接口库

> 



# JVM类生命周期

JVM类加载机制主要包括两个问题：**类加载的时机与步骤** 和 **类加载的方式**。

一个Java对象的创建过程往往包括两个阶段：**类初始化阶段** 和 **类实例化阶段**。



## 类加载的时机

虚拟机规范中并没有对什么时候开始加载一个类进行强制约束，这点可以交给虚拟机的具体实现来自由把握。

## 类初始化时机

虚拟机规范指明 <font color=#00dd00>有且只有</font> 五种情况必须立即对类进行初始化（而这一过程自然发生在加载、验证、准备之后）：

1) 遇到new、getstatic、putstatic或invokestatic这四条字节码指令（注意，newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[]只会直接触发String[]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。

生成这四条指令的最常见的Java代码场景是：

> 使用new关键字实例化对象的时候；
>
> 读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；
>
> 调用一个类的静态方法的时候。

2) 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

5) 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

注意，对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行 **主动引用**。除此之外，所有引用类的方式，都不会触发初始化，称为 **被动引用**。



特别需要指出的是，类的实例化与类的初始化是两个完全不同的概念：

- 类的实例化是指创建一个类的实例(对象)的过程；
- 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。



## 初始化顺序

结果是集合{父类static，子类static，父类大括号，父类构造函数，子类大括号，子类构造函数}的一个子集。

> 核心就是类加载static块优先初始化，子类初始化会触发父类的初始化。
>
> 一个类中，被加载过的静态代码不会被重复加载。
>
> 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。