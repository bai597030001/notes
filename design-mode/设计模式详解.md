# 设计模式六大原则

- 开闭原则
- 里式替换原则
- 依赖倒置原则
- 接口隔离原则
- 迪米特法则
- 合成复用原则





# 创建型模式

创建型模式（Creational Patterns）



- 工厂模式（Factory Pattern）
- 静态工厂模式 （Static Factory）
- 抽象工厂模式（Abstract Factory Pattern）
- 单例模式（Singleton Pattern）
- 多例模式 （Multiton）
- 建造者模式（Builder Pattern）
- 原型模式（Prototype Pattern）
- 对象池模式 （Pool）



## 单例模式

确保一个类只有一个实例，并为整个系统提供一个全局访问点的一种模式方法。

特点：

1、构造方法私有化

2、实例化的变量引用私有化

3、获取实例的方法共有



### 创建实例

饿汉式、懒汉式、双重校验锁、静态内部类、枚举



#### 饿汉式

#### 懒汉式

#### 双重校验锁

#### 静态内部类

#### 枚举



### 应用实例







## 多例模式

1 、多例类可以有多个实例 
2 、多例类必须能够自我创建并管理自己的实例，并向外界提供自己的实例。



### 应用实例

线程池、数据库连接池





# 结构型模式

结构型模式（Structural Patterns）





- 适配器模式（Adapter Pattern）
- 桥接模式（Bridge Pattern）
- 过滤器模式（Filter、Criteria Pattern）
- 组合模式（Composite Pattern）
- 装饰器模式（Decorator Pattern）
- 外观模式（Facade Pattern）
- 享元模式（Flyweight Pattern）
- 代理模式（Proxy Pattern）
- 数据映射模式 （Data Mapper）
- 依赖注入模式 （Dependency Injection）
- 门面模式 （Facade）
- 流接口模式 （Fluent Interface）
- 注册模式 （Registry）









# 行为型模式

行为型模式（Behavioral Patterns）



- 责任链模式（Chain of Responsibility Pattern）
- 命令模式（Command Pattern）
- 解释器模式（Interpreter Pattern）
- 迭代器模式（Iterator Pattern）
- 中介者模式（Mediator Pattern）
- 备忘录模式（Memento Pattern）
- 观察者模式（Observer Pattern）
- 事件监听模式（event listener）
- 状态模式（State Pattern）
- 空对象模式（Null Object Pattern）
- 策略模式（Strategy Pattern）
- 模板模式（Template Pattern）
- 访问者模式（Visitor Pattern）
- 规格模式 *（Specification）







## 事件监听模式

- servlet，tomcat，spring等，内部都使用了事件监听模式

- 事件源 经过 事件的封装 传给监听器，当事件源触发事件后，监听器接收到事件对象可以回调事件的方法 



### 示例

```java
package com.juc.demo.eventListener;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.EventListener;
import java.util.Vector;

public class Demo3 {

    public static void main(String[] args) {
        MyEventSource source = new MyEventSource("first servlet", new Vector<>());

        MyEventListenerImpl listener1 = new MyEventListenerImpl();
        MyEventListenerImpl listener2 = new MyEventListenerImpl();
        MyEventListenerImpl listener3 = new MyEventListenerImpl();

        source.registerListener(listener1);
        source.registerListener(listener2);
        source.registerListener(listener3);

        source.display();
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class MyEventSource {

    String servlet;
    Vector<MyEventListener> listeners;

    public void registerListener(MyEventListener listener) {
        listeners.add(listener);
    }

    public void removeListener(MyEventListener listener) {
        listeners.remove(listener);
    }

    public void display() {
        for (MyEventListener listener : listeners) {
            listener.display(new MyEvent(this));
        }
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class MyEvent {
    MyEventSource source;
}

class MyEvent extends java.util.EventObject {
    /**
     * Constructs a prototypical Event.
     *
     * @param source The object on which the Event initially occurred.
     * @throws IllegalArgumentException if source is null.
     */
    public MyEvent(Object source) {
        super(source);
    }

    @Override
    public MyEventSource getSource() {
        return (MyEventSource) source;
    }

    @Override
    public String toString() {
        return "MyEvent{" +
                "source=" + source +
                '}';
    }
}

/**
 * 所有事件监听器接口都必须扩展 EventListener 接口。
 */
interface MyEventListener extends java.util.EventListener {

    void display(MyEvent var1);
}


/**
 * 事件监听器实现类
 */
class MyEventListenerImpl implements MyEventListener {

    @Override
    public void display(MyEvent var1) {
        System.out.println(var1.getSource().getServlet());
    }
}
```



![](img/Servlet1.jpg)



实现步骤：

 1、首要定义事件源对象

​	如上述MyEventSource。

 2、其次定义事件（状态）对象（该事件对象包装了事件源对象、作为参数传递给监听器、很薄的一层包装类） 

​	如上述MyEvent

 3、最后定义我们的事件侦听器接口和其实现类

​	如上述MyEventListener和MyEventListenerImpl



**综上**：其实事件侦听接口中抽象出来的，就是我们要侦听的事件源中的方法，只是此处需要将包装后的事件类传递进去。



总结
	监听器模式是观察者模式的另一种形态，同样基于事件驱动模型。监听器模式更加灵活，可以对不同事件作出相应。但也是付出了系统的复杂性作为代价的，因为我们要为每一个事件源定制一个监听器以及事件，这会增加系统的负担。 



### 扩展

如上述示例所示，JDK提供了两个接口来帮助实现事件监听模式：`java.util.EventObject` 和 `java.util.EventListener`