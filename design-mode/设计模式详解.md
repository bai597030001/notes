# 事件监听模式

- servlet，tomcat，spring等，内部都使用了事件监听模式

- 事件源 经过 事件的封装 传给监听器，当事件源触发事件后，监听器接收到事件对象可以回调事件的方法 



## 示例

```java
package com.juc.demo.eventListener;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.EventListener;
import java.util.Vector;

public class Demo3 {

    public static void main(String[] args) {
        MyEventSource source = new MyEventSource("first servlet", new Vector<>());

        MyEventListenerImpl listener1 = new MyEventListenerImpl();
        MyEventListenerImpl listener2 = new MyEventListenerImpl();
        MyEventListenerImpl listener3 = new MyEventListenerImpl();

        source.registerListener(listener1);
        source.registerListener(listener2);
        source.registerListener(listener3);

        source.display();
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class MyEventSource {

    String servlet;
    Vector<MyEventListener> listeners;

    public void registerListener(MyEventListener listener) {
        listeners.add(listener);
    }

    public void removeListener(MyEventListener listener) {
        listeners.remove(listener);
    }

    public void display() {
        for (MyEventListener listener : listeners) {
            listener.display(new MyEvent(this));
        }
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class MyEvent {
    MyEventSource source;
}

class MyEvent extends java.util.EventObject {
    /**
     * Constructs a prototypical Event.
     *
     * @param source The object on which the Event initially occurred.
     * @throws IllegalArgumentException if source is null.
     */
    public MyEvent(Object source) {
        super(source);
    }

    @Override
    public MyEventSource getSource() {
        return (MyEventSource) source;
    }

    @Override
    public String toString() {
        return "MyEvent{" +
                "source=" + source +
                '}';
    }
}

/**
 * 所有事件监听器接口都必须扩展 EventListener 接口。
 */
interface MyEventListener extends java.util.EventListener {

    void display(MyEvent var1);
}


/**
 * 事件监听器实现类
 */
class MyEventListenerImpl implements MyEventListener {

    @Override
    public void display(MyEvent var1) {
        System.out.println(var1.getSource().getServlet());
    }
}
```



![](img/Servlet1.jpg)



实现步骤：

 1、首要定义事件源对象

​	如上述MyEventSource。

 2、其次定义事件（状态）对象（该事件对象包装了事件源对象、作为参数传递给监听器、很薄的一层包装类） 

​	如上述MyEvent

 3、最后定义我们的事件侦听器接口和其实现类

​	如上述MyEventListener和MyEventListenerImpl



**综上**：其实事件侦听接口中抽象出来的，就是我们要侦听的事件源中的方法，只是此处需要将包装后的事件类传递进去。



总结
	监听器模式是观察者模式的另一种形态，同样基于事件驱动模型。监听器模式更加灵活，可以对不同事件作出相应。但也是付出了系统的复杂性作为代价的，因为我们要为每一个事件源定制一个监听器以及事件，这会增加系统的负担。 



## 扩展

如上述示例所示，JDK提供了两个接口来帮助实现事件监听模式：`java.util.EventObject` 和 `java.util.EventListener`